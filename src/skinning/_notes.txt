DUAL QUAT SKINNING WITH SCALING ???
- Can scale a quat by the sqrt( scaleValue )
- Scale can be lost with normalization
-- Split into two parts, Build WS first so
   scaling can be passed down the tree better
   then normalize it.
-- Can try not to normalize it as all, only normalize after weighting



DIFFERENT WAY TO HANDLE MATRIX SKINNING

For funky way to handle skeleton that are scaled up & rotated in relation to the mesh
So skeleton & mesh does not match up, so you need a bind + inverseBind & you need to build up

// Vertex Skinning Shader
https://github.com/mrdoob/three.js/blob/f2766a0dfc47a790cd64dec6f9b7132d6fee9fa8/src/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js#L12

// Getting Bone Matrices from Data Texture
https://github.com/mrdoob/three.js/blob/f2766a0dfc47a790cd64dec6f9b7132d6fee9fa8/src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js#L4
https://github.com/mrdoob/three.js/blob/f2766a0dfc47a790cd64dec6f9b7132d6fee9fa8/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js#L9

// Where vec3 transformed gets started
https://github.com/mrdoob/three.js/blob/f2766a0dfc47a790cd64dec6f9b7132d6fee9fa8/src/renderers/shaders/ShaderChunk/begin_vertex.glsl.js#L4

// BindPose Generated
https://github.com/mrdoob/three.js/blob/f2766a0dfc47a790cd64dec6f9b7132d6fee9fa8/src/objects/SkinnedMesh.js#L150
https://github.com/mrdoob/three.js/blob/dev/src/objects/Skeleton.js#L64

// Apply Bone Transform
https://github.com/mrdoob/three.js/blob/3f53946c9a2ef1795bf95900af3a8e71710a5aa6/src/objects/SkinnedMesh.js#L223

https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/Michelle.glb

ThreeJS also handles building up the vertices differently by
mul the initial pos by each matrix + weight, Then adding it together.
This might be more efficient since mat * mat is more costly then mat * vec3
but there is one drawback, without a combined boneMatrix, there is no way
to compute the normal matrix in the ossos example.

Either way, this example should be explored, expecially with the idea of using
bind & bindInverse before/after computing the skinned vertex.
Main goal is to first to get the model to render to match skeleton

When the offet exists, the skinned mesh will have a bindMatrix that is identity BUT
will have a bindMatrixInverse that is the invert of the offset transform. This seems
to fix to make it look correct in yUp & in meters.

There may also be weirdness related to the inverse matrices in the gtlf file. The bindpose
might also have the offset built in before the root for all I know.

Offset
Quat (4) [0.70710688829422, 0, 0, 0.7071066498756409] Scale (3) [0.009999999776482582, 0.009999999776482582, 0.009999999776482582]

bindMatrix Inverse
[ 
  100.00000223517424, 0, 0, 0, 
  0, -0.000030294629646984445, -100.00000565802227, 0, 
  0, 100.00000565802227, -0.000030294629646984445, 0, 
  0, 0, 0, 1
]

vec3 transformed = position;
vec4 skinVertex  = bindMatrix * vec4( transformed, 1.0 );

vec4 skinned = vec4( 0.0 );
skinned += boneMatX * skinVertex * skinWeight.x;
skinned += boneMatY * skinVertex * skinWeight.y;
skinned += boneMatZ * skinVertex * skinWeight.z;
skinned += boneMatW * skinVertex * skinWeight.w;

transformed = ( bindMatrixInverse * skinned ).xyz;
