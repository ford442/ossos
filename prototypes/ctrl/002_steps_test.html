<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import SphereMat                from '../_lib/shader/SphereMat.js';
import CanvasKeyboardHandlers   from '../_lib/misc/CanvasKeyboardHandlers.js';
import { Vec3, Quat }           from '../../src/index';
// #endregion

// #region MAIN
let Debug;
let App = useDarkScene( useThreeWebGL2() );
let Ref   = {};

window.addEventListener( "load", async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 45, 20, 4, [ 0, 0.1, 0 ] );
    Debug   = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.sim = new Simulator();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();
});

function onPreRender( dt, et ){
    Ref.sim.update( dt );
}
// #endregion

// #region HELPERS
const TAO = Math.PI * 2;

function wrapPI( v ){
    const vv = v % ( Math.PI * 2 );
    return ( Math.abs(vv) <= Math.PI )? vv : vv + ( Math.PI * 2 ) * -Math.sign(vv);
}

function wrapTAO( v ){
    const vv = v % ( Math.PI * 2 );
    return ( vv >= 0 )? vv : vv + ( Math.PI * 2 );
}

function clampN1( v ){ return Math.max( -1, Math.min( 1, v ) ); }

function lerp( a, b, t ){ return a * (1-t) + b * t; }
function sigmoid( t, k=0 ){ // Over 0, Eases in the middle, under eases in-out
    // this uses the -1 to 1 value of sigmoid which allows to create easing at 
    // start and finish. Can pass in range 0:1 and it'll return that range.
    // Closer to 1 is slower to start
    // Zero is linear
    // Closer to -1 is faster to start
    // https://dhemery.github.io/DHE-Modules/technical/sigmoid/
    // https://www.desmos.com/calculator/q6ukniiqwn
    return ( t - k*t ) / ( k - 2*k*Math.abs(t) + 1 );
}


function arcLength( rad, radius ){ return ( rad / TAO ) * ( TAO * radius ); }

// #endregion

// https://www.youtube.com/watch?v=Ul0Gilv5wvY&list=PLCUClXmi3aSDDWjM54xVszesDTcIiHHo5

// cLength = PI * ( 2 * Radius )                     // Complete distance around the circle
// rad = TAO * ( Distance / cLength )                // Speed/Movement to sphere arc rotation
// ArcLength = ( Rad / TAO ) * ( 2 * PI * RADIUS )   // Length of a specific arc
// Radius = arcLength / arcRadians

class Simulator{
    step        = 0;
    maxStep     = 80;
    moveInc     = 0.5;             
    turnInc     = 120 * Math.PI / 180;
    turnRad     = 0;
    pos         = new Vec3();
    rot         = new Quat();
    
    time        = 0;
    dist        = 0;
    ticks       = 0;
    constructor(){}

    update( dt ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // if( this.step >= this.maxStep ) return;
        // this.step++;

        if( this.time >= 1 ) return;
        // Debug.reset();
        this.time += dt;
        this.ticks++;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const v = new Vec3();
        const dir = new Vec3();
        
        this.turnRad += this.turnInc * dt;
        this.rot.fromAxisAngle( Vec3.UP, this.turnRad );

        dir
            .fromQuat( this.rot, Vec3.FORWARD )
            .scale( this.moveInc * dt );

        // const v = new Vec3( dir ).norm().scale( 0.5 ).add( this.pos );
        // Debug.ln.add( this.pos, v, 0x909090 )

        this.dist += dir.len;

        this.pos.add( dir );
        Debug.pnt.add( this.pos, 0x909090, 1 );

        console.log( 'Time', this.ticks, this.time );
        console.log( '-- TurnAngle', this.turnRad * 180 / Math.PI, 'Dist', this.dist );
        console.log( '-- Step', this.moveInc * dt, dir.len );

        const rr = Vec3.angle( Vec3.FORWARD, v.copy( this.pos ).norm() );
        console.log( '-- Radius', this.pos.len, 'Angle', rr * 180 / Math.PI, 'ArcLen', arcLength( rr, this.pos.len ) );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // One second prediction
        if( this.time < 1 ) return; // Render prediction only once

        this.rot.fromAxisAngle( Vec3.UP, this.turnInc );
        dir.fromQuat( this.rot, Vec3.FORWARD );
        dir.scale( this.moveInc );
        v.fromAdd( dir, Vec3.UP );
        Debug.ln.add( dir, v, 0x00ff00 );

        console.log( "Pred Dist", dir.len );
        
    }
}


// Turn control with ease in/out interolation
// def ease_in_out(t):
//     if t < 0.5:
//         return 2 * t * t
//     else:
//         return -1 + (4 - 2 * t) * t

// def update(deltaTime):
//     # Calculate the raw t based on speed and deltaTime
//     raw_t = speed * deltaTime
//     # Clamp raw_t to [0, 1]
//     clamped_t = min(max(raw_t, 0), 1)
//     # Apply the easing function
//     eased_t = ease_in_out(clamped_t)
    
//     # Interpolate with eased_t
//     new_direction = lerp(current_direction, target_direction, eased_t)
//     return new_direction

// Since lerp can be an issue going from FWD to BAK, can lerp QUATS instead as a cheaper option for slerp


</script></body></html>