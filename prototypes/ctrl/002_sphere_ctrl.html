<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import SphereMat                from '../_lib/shader/SphereMat.js';
import CanvasKeyboardHandlers   from '../_lib/misc/CanvasKeyboardHandlers.js';
import { Vec3, Quat }           from '../../src/index';
// #endregion

// #region MAIN
let Debug;
let App = useDarkScene( useThreeWebGL2() );
let Ref   = {};

window.addEventListener( "load", async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 45, 20, 10, [ 0, 0.8, 0 ] );
    Debug   = await useVisualDebug( App );
    Ref.kb  = new CanvasKeyboardHandlers( App.renderer.domElement, false ).enable();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.sphere = new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 16 ), SphereMat() );
    Ref.sphere.position.y = 1.0;
    App.scene.add( Ref.sphere );
    
    Ref.baller = new Baller( Ref.sphere );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();
});

function onPreRender( dt, et ){
    const arrows = Ref.kb.getArrowAxes();
    Debug.reset();
    Ref.baller.update( dt, arrows ).debug();
}
// #endregion

// #region HELPERS
const TAO = Math.PI * 2;

function wrapPI( v ){
    const vv = v % ( Math.PI * 2 );
    return ( Math.abs(vv) <= Math.PI )? vv : vv + ( Math.PI * 2 ) * -Math.sign(vv);
}

function wrapTAO( v ){
    const vv = v % ( Math.PI * 2 );
    return ( vv >= 0 )? vv : vv + ( Math.PI * 2 );
}

function clampN1( v ){ return Math.max( -1, Math.min( 1, v ) ); }

function lerp( a, b, t ){ return a * (1-t) + b * t; }
function sigmoid( t, k=0 ){ // Over 0, Eases in the middle, under eases in-out
    // this uses the -1 to 1 value of sigmoid which allows to create easing at 
    // start and finish. Can pass in range 0:1 and it'll return that range.
    // Closer to 1 is slower to start
    // Zero is linear
    // Closer to -1 is faster to start
    // https://dhemery.github.io/DHE-Modules/technical/sigmoid/
    // https://www.desmos.com/calculator/q6ukniiqwn
    return ( t - k*t ) / ( k - 2*k*Math.abs(t) + 1 );
}
// #endregion

// https://www.youtube.com/watch?v=Ul0Gilv5wvY&list=PLCUClXmi3aSDDWjM54xVszesDTcIiHHo5

// cLength = PI * ( 2 * Radius )                     // Complete distance around the circle
// rad = TAO * ( Distance / cLength )                // Speed/Movement to sphere arc rotation
// ArcLength = ( Rad / TAO ) * ( 2 * PI * RADIUS )   // Length of a specific arc
class Baller{
    // #region MAIN
    radius      = 1;
    arcLen      = Math.PI * this.radius * 2; // C = Pi * 2R;
    meshRot     = new Quat();

    turnInc     = 90 * Math.PI / 180;  // Turn angle per second
    turnRad     = 0;                    // Current Y Rotation in radians
    turnRot     = new Quat();           // Current Y Rotation in quaterion
    
    moveK       = -0.2;         // Curve Option of sigmod
    moveT       = 0;            // Current T value
    moveInc     = 0.5;          // T Increment Per Second
    moveSpeed   = 0;            // Current speed value
    moveFwdMax  = 5.0;          // Max speed going forward per second
    moveRevMax  = -3.0;         // Max speed going reverse per second
    moveRad     = 0;            // Current rotation as Radians
    moveRot     = new Quat();   // Current rotation as a quaternion

    constructor( mesh ){
        this.mesh = mesh;
        console.log( 'arcLen', this.arcLen, this.arcLen * 0.5 );
    }
    // #endregion

    // #region GETTERS

    currentPos(){ return new Vec3( this.mesh.position.toArray() ).add( [0,-1.0,0] ); }
    currentDir(){ return new Vec3().fromQuat( this.turnRot, Vec3.FORWARD ); }
    
    // #endregion

    // #region MOVEMENT
    update( dt, dir ){
        this.updateTurning( dir[0], dt );
        this.updateMomentum( dir[1], dt );
        this.applyMovement( dt );

        // this.predictStep( dt );
        // this.predictCurve( dir[0], dt );
        // this.predictPath( dir[0], dt );

        return this;
    }

    applyMovement( dt ){        
        // Apply speed as rotation
        this.meshRot.fromMul( this.turnRot, this.moveRot );
        this.mesh.quaternion.fromArray( this.meshRot );
        
        // Apply speed as translation
        const v = new Vec3();
        v   .fromQuat( this.turnRot, Vec3.FORWARD )
            .scale( this.moveSpeed * dt )
            .add( this.mesh.position.toArray() );
        
        this.mesh.position.fromArray( v );
    }

    updateMomentum( d, dt ){
        if( d !== 0 ){
            this.moveT = clampN1( this.moveT + this.moveInc * dt * Math.sign( d ) );
        }else{
            this.moveT = Math.max( 0, ( Math.abs( this.moveT ) - this.moveInc * dt ) ) * Math.sign( this.moveT );
        }

        if( this.moveT !== 0 ){
            const t        = sigmoid( Math.abs( this.moveT ), this.moveK );
            this.moveSpeed = ( this.moveT > 0 )
                            ? lerp( 0, this.moveFwdMax, t )
                            : lerp( 0, this.moveRevMax, t );

            const vel = this.moveSpeed * dt;
            const rad = ( Math.PI * 2 ) * ( vel / this.arcLen ); // Speed to sphere arc rotation

            this.moveRad = wrapTAO( this.moveRad + rad );
            this.moveRot.fromAxisAngle( [1,0,0], this.moveRad );
        }else{
            this.moveSpeed = 0;
        }
    }

    updateTurning( d, dt ){
        if( d !== 0 ){
            this.turnRad = wrapPI( this.turnRad + -d * this.turnInc * dt );
            this.turnRot.fromAxisAngle( [0,1,0], this.turnRad );
        }
    }
    // #endregion

    // #region PREDICTIONS

    // Predict the next foot
    predictStep( dt ){
        const curPos     = this.currentPos();
        const sign       = Math.sign( this.moveSpeed );
        const isFwd      = ( sign >= 0 );   
        const curRadStep = this.moveRad % Math.PI;                          // Every PI rotation is a step.
        const nxtRadStep = ( isFwd )? Math.PI - curRadStep : curRadStep;    // Forward moving toward PI, Reverse moving toward Zero
        const nxtDist    = ( nxtRadStep / TAO ) * this.arcLen;              // Convert angle left to distance

        const dir        = this.currentDir();
        const pos        = new Vec3().fromScale( dir, nxtDist * sign ).add( curPos );

        // Sim LEFT & RIGHT Foot prediction
        // If moving toward PI is Left Foot ( red ), else Right foot ( green )
        const isAlt      = ( Math.floor( this.moveRad / Math.PI ) + (( isFwd )? 1 : 2 ) ) % 2;
        Debug.pnt.add( pos, isAlt? 0xff0000 : 0x00ff00 );

        // const timeLeft = ( this.moveSpeed === 0 )? 0 : nxtDist / this.moveSpeed;
        // console.log( 'Next', nxtDist, 'Speed', this.moveSpeed, 'sec', timeLeft );
    }

    predictCurve( turn, dt ){
        // Current Place
        // Current direction
        // Is turning?
        // -- What is the rate of turning per second

        const curPos     = this.currentPos();
        const curRad     = this.turnRad;
        const inc        = this.turnInc;
        const rot        = new Quat().fromAxisAngle( [0,1,0], curRad );

        const dir        = new Vec3().fromQuat( rot, Vec3.FORWARD );
        const v          = new Vec3().fromScale( dir, 2 ).add( curPos );
        

        const prev = new Vec3( this.currentPos() );
        for( let i = 1; i <= 4; i++ ){
            const rad = this.turnRad + ( this.turnInc * 0.1 * i );
            rot.fromAxisAngle( Vec3.UP, rad );
            dir.fromQuat( rot, Vec3.FORWARD ).scale( 1.0 );
            v.fromAdd( prev, dir );

            Debug.ln.add( prev, v, 0x00ffff );
            prev.copy( v );
        }
    }

    predictPath( turn, dt ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const curPos        = this.currentPos();
        const speedSign     = Math.sign( this.moveSpeed );
        const curMoveRad    = this.moveRad % Math.PI;
        const nxtMoveRad    = ( speedSign >= 0 )? Math.PI - curMoveRad : curMoveRad;    // Fwd is toward PI, Rev is toward 0
        const nxtDist       = ( nxtMoveRad / TAO ) * this.arcLen;                       // Convert angle to next step into distance
        const nxtTime       = ( this.moveSpeed === 0 )? 0 : nxtDist / this.moveSpeed;   // Time to reach next step

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        let rad = this.turnRad;
        if( turn !== 0 ) rad = wrapPI( rad + ( -turn * this.turnInc * nxtTime ) );


        let isAlt = ( Math.floor( this.moveRad / Math.PI ) + (( speedSign >= 0 )? 1 : 2 ) ) % 2;        

        const prev = new Vec3( curPos );
        const rot = new Quat().fromAxisAngle( Vec3.UP, rad );
        const dir = new Vec3().fromQuat( rot, Vec3.FORWARD );
        const v   = new Vec3();

        dir.scale( nxtDist * speedSign );
        v.fromAdd( prev, dir );
        prev.copy( v );

        Debug.ln.add( curPos, v, 0x00ffff );
        Debug.pnt.add( v, isAlt? 0xff0000 : 0x00ff00 );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const step  = this.arcLen * 0.5;
        const stepT = 1; // ( this.moveSpeed === 0 )? 0 : step / Math.abs( this.moveSpeed ); // How many seconds to take a step

        for( let i=1; i <=2; i++ ){
            rad = wrapPI( rad + ( -turn * this.turnInc * stepT ) ); // How much turning completed per step
            rot.fromAxisAngle( Vec3.UP, rad );                  
            dir.fromQuat( rot, Vec3.FORWARD ).scale( step * speedSign );
            
            v.fromAdd( prev, dir );
            isAlt = ( isAlt + 1 ) % 2;

            Debug.ln.add( prev, v, 0x00ffff );
            Debug.pnt.add( v, isAlt? 0xff0000 : 0x00ff00 );
            
            prev.copy( v );
        }

        // console.log( 'NDist', nxtDist, 'Speed', this.moveSpeed, 'nSec', nxtTime );
        // console.log( rad * Math.PI / 180 );
    }

    // #endregion

    // #region DEBUGGING
    debug(){
        // See Direction
        const offset    = [0,-1.1,0];
        const o         = new Vec3( this.mesh.position.toArray() ).add( offset );
        const v         = new Vec3().fromQuat( this.turnRot, Vec3.FORWARD ).scale( 2 ).add( o );
        Debug.ln.add( o, v, 0x00ff00 );
    }
    // #endregion
}



class CamFollower{

    constructor( obj, camera, orbit ){
        // orbit.target.fromArray()
        // orbit.update();
    }

    // https://threejs.org/docs/index.html?q=Orbit#examples/en/controls/OrbitControls
    // const sphericalLook = ( lon, lat, radius, target=null )=>{
    //     const phi 	= ( 90 - lat )  * Math.PI / 180;
    //     const theta = ( lon + 180 ) * Math.PI / 180;

    //     camera.position.set(
    //         -(radius * Math.sin( phi ) * Math.sin(theta)),
    //         radius * Math.cos( phi ),
    //         -(radius * Math.sin( phi ) * Math.cos(theta))
    //     );

    //     if( target ) camCtrl.target.fromArray( target );
    //     camCtrl.update();
    //     return self;
    // };

}
</script></body></html>