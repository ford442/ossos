<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
// import useTransformControl          from '../_lib/useTransformControl.js';
import Util                         from '../_lib/misc/Util.js';

import { 
    Armature,
    Quat, Vec3, Transform,
} from '../../src/index';

// #endregion

// #region MAIN
let Debug;
let App = useDarkScene( useThreeWebGL2(), { ambient:0xffffff } );
let Ref = {
    // gizmo : useTransformControl( App ).useAxes(),
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 5, [ 0, 0.6, 0 ] );
    Debug = await useVisualDebug( App );
    // Ref.gizmo.setPos( [0,1,0] );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const arm = new Armature();
    const b0  = arm.addBone( { name:'b0', pos:[0,0,0], parent:undefined } );
    const b1  = arm.addBone( { name:'b1', pos:[0,0.5,0], parent:b0, len:0.5 } );
    arm.bind( 0.2 );

    const pose = arm.newPose();
    Ref.target = new IKTarget().setPos( [0.5,0.5,0.5] );
    Ref.chain  = new IKChain( arm.getBones( ['b0','b1'] ) );

    // New API Idea : Composite IK Solvers
    const limbSolver = ( target, chain, pose )=>{
        chain.updateRootFromPose( pose );           // Get root world transform
        aimChainSolver( target, chain, pose );      // Aim chain root bone at IK Target

        if( chain.isReachable( target.pos ) ){
            twoBoneSolver( target, chain, pose );   // Bend bones to reach target
        }else{
            chain.resetWorld( 1 );                  // Straighten remaining bones
        }

        chain.setLocalRotPose( pose );              // Convert to local space & save to pose
    };

    limbSolver( Ref.target, Ref.chain, pose );
    pose.updateWorld();

    Util.debugBones( pose.bones, Debug );
    Debug.pnt.add( Ref.target.pos, 0x00ff00, 3 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //App.createRenderLoop( onPreRender ).start();
    App.renderLoop();
});

// Ref.gizmo.onMove = p=>{};
// function onPreRender( dt, et ){}
// #endregion

class BoneAxes{
    x = new Vec3( 1, 0, 0 ); // Right
    y = new Vec3( 0, 1, 0 ); // Up      - Point
    z = new Vec3( 0, 0, 1 ); // Forward - Twist

    // look( fwd, up=[0,1,0] ){
    //     this.z.copy( fwd ).norm();                  // Forward
    //     this.x.fromCross( up, this.z ).norm();      // Orthogonal Right
    //     this.y.fromCross( this.z, this.x ).norm();  // Orthogonal Up
    //     return this;
    // }

    // getFromQuat( q, ax = new Axes() ){
    //     ax.x.fromQuat( q, this.x );
    //     ax.y.fromQuat( q, this.y );
    //     ax.z.fromQuat( q, this.z );
    //     return ax;
    // }

    rotInvQuat( q ){
        const qi = new Quat( q ).invert();
        this.x.fromQuat( qi, this.x );
        this.y.fromQuat( qi, this.y );
        this.z.fromQuat( qi, this.z );
        return this
    }
}


class IKTarget{
    pos = new Vec3();

    setPos( v ){
        this.pos.copy( v );
        return this;
    }
}

class IKLink{
    index     = -1;
    pindex    = -1;
    len       = 0;
    bind      = new Transform();
    world     = new Transform();

    constructor( bone ){
        this.index  = bone.index;
        this.pindex = bone.pindex;
        this.len    = bone.len;
        this.bind.copy( bone.local );
    }
}

class IKChain{
    links  = [];    // Link collection
    len    = 0;     // Total Length of chain
    axes   = new BoneAxes();
    pworld = new Transform();

    constructor( bones=null ){
        if( bones ) this.addBones( bones );
    }

    isReachable( targetPos ){
        return ( Vec3.distSqr( targetPos, this.links[0].world.pos ) < this.len**2 );
    }

    addBones( bones ){
        for( let b of bones ){
            this.links.push( new IKLink( b ) );
            this.len += b.len;
        }
        return this;
    }

    updateRootFromPose( pose ){
        // Get the World transform to the root's parent bone.
        pose.getWorldTransform( this.links[0].pindex, this.pworld );

        // Then compute the root using the parent & the local bind transform of the link
        this.links[0].world.fromMul(
            this.pworld,
            this.links[ 0 ].bind
        );
    }

    resetWorld( startIdx=-1, endIdx=-1 ){
        if( startIdx < 0 ) startIdx = 0;
        if( endIdx < 0 )   endIdx   = this.links.length-1;

        let lnk;
        let pWS;
        for( let i=endIdx; i <= endIdx; i++ ){
            lnk  = this.links[ i ];
            pWS  = ( i === 0 )? this.pworld : this.links[ i-1 ].world;
            lnk.world.fromMul( pWS, lnk.bind );
        }

        return this;
    }

    setLocalRotPose( pose ){
        let lnk;
        let pRot;

        for( let i=0; i < this.links.length; i++ ){
            lnk  = this.links[ i ];
            pRot = ( i === 0 )? this.pworld.rot : this.links[ i-1 ].world.rot;
            
            pose.bones[ lnk.index ].local.rot
                .copy( lnk.world.rot )
                .pmulInvert( pRot );
        }

        return this;
    }

    // bindAxes( skel ){
    //     const q = skel.getWorldRotation( this.links[0].index );
    //     this.axes.rotInvQuat( q );
    //     return this;
    // }
}


// Debug.ln.add( cTran.pos, Vec3.scaleThenAdd( 3, twistDir, cTran.pos ), 0xff0000 );

function aimChainSolver( tar, chain, pose ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
    const pTran = chain.pworld;
    const cTran = chain.links[0].world;

    // Get direction from bone to target
    const tarDir = new Vec3( tar.pos )
        .sub( cTran.pos )
        .norm();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Swing Rotation - Compute bone's currect pointing direction ( Y ).
    const dir = new Vec3( chain.axes.y ).transformQuat( cTran.rot );
    const rot = new Quat()
        .fromSwing( dir, tarDir ) // Create Swing Rotation
        .mul( cTran.rot );        // Apply swing to current bone rotation

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Reset Twisting Rotation

    // With swing rotation now aligned to the target direction,
    // test to see if the target direction is pointing directly at a pole
    // The reset direction will change depending on the pole.
    const twistDir      = new Vec3(); 
    const swingTwistDir = new Vec3();
    const orthDir       = new Vec3();

    // Get the twist dir from unmodifed bone rotation
    twistDir.fromQuat( cTran.rot, chain.axes.z );

    // -----------------------------------------
    // Correct twist direction by rotating it if it matches the swing point direction
    // Swing dir should now match target dir, so we can reuse that for our dot check
    const dot = Vec3.dot( twistDir, tarDir );
    if( Math.abs( dot ) > 0.9999 ){
        // Compute rotation axis to spin the Z direction
        // Can use X since its orthogonal to Y & Z already
        orthDir.fromQuat( cTran.rot, chain.axes.x );

        // Spin the twist direction 90 degrees based on the sign of the dot product
        // So if positive spin downward else spin upward.
        twistDir.transformQuat(
            Quat.axisAngle( orthDir, Math.PI * 0.5 * Math.sign( dot ) )
        );
    }

    // -----------------------------------------
    // Get the twist direction after swing rotation is applied
    swingTwistDir.fromQuat( rot, chain.axes.z );

    // With our swing pointing dir matching our target dir, we can use it instead of 
    // generating it to help realign our twist direction by finding the orthogonal dir
    orthDir.fromCross( tarDir, twistDir ); // cross( FWD, UP )    = RIGHT
    twistDir.fromCross( orthDir, tarDir ); // cross( RIGHT, FWD ) = Corrected UP
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create rotation that will reset the twisting so its axis aligned
    cTran.rot.fromMul(
        Quat.swing( swingTwistDir, twistDir ),
        rot
    );
}

function twoBoneSolver( tar, chain, pose ){
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Get our two bones
    const l0 = chain.links[ 0 ];  // aLen               
    const l1 = chain.links[ 1 ];  // bLen

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // FIRST BONE
    const bendAxis = Vec3.fromQuat( l0.world.rot, chain.axes.x );  // X axis will act as our bending rotation
    const cLen     = Vec3.dist( l0.world.pos, tar.pos );           // Compute the 3rd side of the triangle by using the distance between root & target
    let   rad;

    rad	= lawcos_sss( l0.len, cLen, l1.len );       // Get the Angle between First Bone and Target.
    l0.world.rot.pmulAxisAngle( bendAxis, -rad );   // Apply Bending Rotation

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // SECOND BONE
    // Need to rotate from Right to Left, So take the angle and subtract it from 180 to rotate from 
    // the other direction. Ex. L->R 70 degrees == R->L 110 degrees
    rad	= Math.PI - lawcos_sss( l0.len, l1.len, cLen );
    l1.world.rot
        .fromMul( l0.world.rot, l1.bind.rot )   // Create unmodified ws rotation for bone 2
        .pmulAxisAngle( bendAxis, rad );        // Apply Bending Rotation
}

function lawcos_sss( aLen, bLen, cLen ){
    // Law of Cosines - SSS : cos(C) = (a^2 + b^2 - c^2) / 2ab
    // The Angle between A and B with C being the opposite length of the angle.
    const v = ( aLen**2 + bLen**2 - cLen**2 ) / ( 2 * aLen * bLen );    
    return Math.acos( Math.min( 1, Math.max( -1, v ) ) );  // Clamp to prevent NaN Errors
}

</script></body></html>