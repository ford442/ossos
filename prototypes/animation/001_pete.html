<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import Util                         from '../_lib/misc/Util.js';
import fetchTexture                 from '../_lib/misc/fetchTexture.js';
// import Gltf2                        from '../_lib/gltf2Parser.es.js';
import GltfUtil, { Gltf2 }          from '../_lib/misc/GltfUtil.js';

import { Armature, Pose, TranMatrixSkin, BoneSockets, Maths, PoseAnimator, Clip, LerpType, TrackQuat, TrackVec3, Quat } from '../../src/index';

import MatrixSkinMaterial           from '../_lib/customSkinning/MatrixSkinMaterial.js';
//#endregion

//#region MAIN
let App = useDarkScene( useThreeWebGL2() );
let Ref = { 
    left    : false,
    right   : false,
};
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 20, 20, 5, [ 0, 1, 0 ] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create Skinned Mesh from GLTF Model
    const tex  = await fetchTexture( '/prototypes/_res/models/pete/pete_texture.png', false );
    const gltf = await Gltf2.fetch( '/prototypes/_res/models/pete/pete.gltf' );
    const bGeo = GltfUtil.loadGeoBuffers( gltf, 'Character' )[0];
    const arm  = GltfUtil.parseArmature( gltf );
    const pose = arm.newPose( 'skin' );
    
    const skin = arm.useSkin( TranMatrixSkin );
    const mat  = MatrixSkinMaterial( tex, arm.skin );

    const mesh = new THREE.Mesh( bGeo, mat );
    App.scene.add( mesh );

    console.log( 'Get', gltf.getAnimationNames() )

    // Give it a handler to update THREEJS Objects
    const sockets = new BoneSockets( (t, obj)=>{
        obj.position.fromArray( t.pos );
        obj.scale.fromArray( t.scl );
        obj.quaternion.fromArray( t.rot );
    });

    sockets.add( 'head',  pose.getBone( 'head' ),   [0,0,0] );
    sockets.add( 'handl', pose.getBone( 'hand.l' ), [0,0.1,-0.01] );
    sockets.add( 'handr', pose.getBone( 'hand.r' ), [0,0.1,-0.01] );

    Ref.sockets = sockets;

    const glAnim = gltf.getAnimation( 'Walking' );  // Walking Attack_RightHand_Overhead   
    const clip = gltfClip( glAnim, arm.poses.bind );
    clip.addEvent( 'FootL_Down', 0 );
    clip.addEvent( 'FootR_Down', 13 );

    const animator = new PoseAnimator();
    animator.scale = 1.0;
    animator.setClip( clip );
    animator.onEvent = onAnimationEvent;

    
    // animator.atFrame( 0 );
    // animator.updatePose( pose );

    Ref.animator = animator;
    Ref.pose     = pose;
    Ref.skin     = skin;

    pose.updateWorld();
    skin.updateFromPose( pose );
    Util.debugBones( pose.bones, Debug, 0.05, 0.8 );
    sockets.debugAll( pose, Debug );

    // console.log( pose.bones );

    const q = new Quat();
    const mHelmet = gltfGetAsset( gltf, 'Helmet', tex );
    App.scene.add( mHelmet );
    sockets.attach( 'head', mHelmet );

    const mSword = gltfGetAsset( gltf, 'Sword', tex );
    App.scene.add( mSword );
    q.rotZ( 90 * Maths.DEG2RAD );
    q.rotY( 180 * Maths.DEG2RAD );
    sockets.attach( 'handr', mSword, null, q );

    const mShield = gltfGetAsset( gltf, 'Shield', tex );
    App.scene.add( mShield );
    q.identity();
    q.rotZ( 90 * Maths.DEG2RAD );
    sockets.attach( 'handl', mShield, [0,0,0.14], q );

    sockets.updateFromPose( pose );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Ref.shake = cameraShake( App.camera );
    App.createRenderLoop( onPreRender ).start(); 
    // App.renderLoop();
});
//#endregion

function onPreRender( dt, et ){
    Ref.animator
        .step( dt )
        .updatePose( Ref.pose );
    
    Ref.pose.updateWorld();
    Ref.skin.updateFromPose( Ref.pose );
    Ref.sockets.updateFromPose( Ref.pose );

    Debug.pnt.reset();
    Debug.ln.reset();
    Util.debugBones( Ref.pose.bones, Debug, 0.05, 0.8 );

    Debug.pnt.add( [0.5,0.2,0],  (Ref.left)?  0x00ff00:0xff0000, 4 );
    Debug.pnt.add( [-0.5,0.2,0], (Ref.right)? 0x00ff00:0xff0000, 4 );

    // Ref.shake.update();
}

function onAnimationEvent( evtName ){
    switch( evtName ){
        case 'FootL_Down':
            Ref.left  = true;
            Ref.right = false;
            
            break;
        case 'FootR_Down':
            Ref.left  = false;
            Ref.right = true;
            // Ref.shake.start();
            break;
    }
}

function gltfClip( anim, pose ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const clip = new Clip( anim.name );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    let i;
    for( i of anim.timestamps ){
        if( i.data )                         clip.timeStamps.push( new Float32Array( i.data ) ); // Clone TimeStamp Data so its not bound to GLTF's BIN
        if( i.elementCnt > clip.frameCount ) clip.frameCount = i.elementCnt;                     // Find max frame counts
        if( i?.boundMax[0] > clip.duration ) clip.duration   = i.boundMax[0];                    // Find full duration
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    let gTrack; // Gltf Track
    let oTrack; // Ossos Track
    let bName;  // Bone Name
    let reBoneFilter = new RegExp( /(root|hips?)/i ); // Only use Vec3 tracks for root or hip bone

    for( gTrack of anim.tracks ){
        // -------------------------------------------
        if( !gTrack.keyframes.data ){
            console.error( 'GLTF Animation Track has no keyframe data' );
            continue;
        }

        // -------------------------------------------
        oTrack = null;
        switch( gTrack.transform ){
            // Rotation
            case 0: oTrack = new TrackQuat( gTrack.interpolation ); break;

            // Translation
            case 1:
                bName = pose.bones[ gTrack.jointIndex ].name;
                if( reBoneFilter.test( bName ) ){
                    oTrack = new TrackVec3( gTrack.interpolation ); break;
                }
                break;

            // Scale
            case 2: break;
        }

        // -------------------------------------------
        if( !oTrack ) continue;

        oTrack.setData( gTrack.keyframes.data );
        oTrack.boneIndex = gTrack.jointIndex;
        oTrack.timeIndex = gTrack.timeStampIndex;

        clip.tracks.push( oTrack );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    return clip;
}

function cameraShake( camera ){
    const pos       = [0,0,0];
    const cur       = [0,0,0];
    const tar       = [0,0,0];
    let isRunning   = false;
    let cnt         = 0;  
    let lmt         = 5;
    let cycle       = 0;

    return {
        start: ()=>{
            const p = camera.position.toArray();
            pos[ 0 ] = p[0];
            pos[ 1 ] = p[1];
            pos[ 2 ] = p[2];
            isRunning = true;
            cycle = 0;
            cnt = 0;
        },

        update( dt ){
            if( !isRunning ) return;

            if( cnt === 0 ){
                cycle++;
                if( cycle > 5 ){
                    isRunning = false;
                    camera.position.x = pos[0];
                    camera.position.y = pos[1];
                    camera.position.z = pos[2];
                    return;
                }

                tar[ 0 ] = (Math.random() * 0.3 + -0.15) + pos[0];
                tar[ 1 ] = (Math.random() * 0.3 + -0.15) + pos[1];
                tar[ 2 ] = (Math.random() * 0.3 + -0.15) + pos[2];

                cur[0] = pos[0];
                cur[1] = pos[1];
                cur[2] = pos[2];
            }

            let t  = cnt / lmt;
            let ti = 1 - t;

            camera.position.x = cur[0] * ti + tar[0] * t;
            camera.position.y = cur[1] * ti + tar[1] * t;
            camera.position.z = cur[2] * ti + tar[2] * t;

            cnt++;
            if( cnt > lmt ) cnt = 0;
        },
    }
}

// #region GLTF HELPERS

function gltfGetAsset( gltf, name, tex ){
    const bGeo = GltfUtil.loadGeoBuffers( gltf, name, false )[0];
    const mat  = new THREE.MeshBasicMaterial( {map:tex} );
    return new THREE.Mesh( bGeo, mat );
}

// #endregion

</script></body></html>