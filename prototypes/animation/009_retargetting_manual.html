<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import GltfUtil, { Gltf2 }              from '../_lib/misc/GltfUtil.js';
import Util                             from '../_lib/misc/Util.js';

import { Armature, Pose, PoseAnimator, TranMatrixSkin,
    BoneMap, Retarget } 
    from '../../src/index';

import MatrixSkinMaterial               from '../_lib/customSkinning/MatrixSkinMaterial.js';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 45, 20, 5, [0.75,0.5,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.anim  = await Animation.fetch( 'Catwalk' );
    Ref.char0 = await Character.fetch( '/prototypes/_res/models/nabba/nabba.gltf' );

    Ref.char0.setPos( [1.5,0,0] );

    App.scene.add( Ref.char0.mesh );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.rt0 = new Retarget();
    Ref.rt0
        // .autoBindTPoses(
        //     Ref.anim.arm.poses.opose,   // Use Offset Pose because its a mixamo animation
        //     Ref.char0.arm.bindPose,     // Character is in a TPose by default
        // )

        // MUST set poses before binding bones
        .useTPoses( 
            Ref.anim.arm.poses.opose,   // Use Offset Pose because its a mixamo animation
            Ref.char0.arm.bindPose,     // Character is in a TPose by default
        )

        // Bind a collection of bones mirroring bones
        .bindBatch( boneMap )

        .animator
            .setClip( Ref.anim.clip )
            .usePlacementReset( [0,0,1] ) // This animation uses Z for up.
            .start();

    // onPreRender( 0.1 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();
});

function onPreRender( dt, et ){
    Debug.pnt.reset();
    Debug.ln.reset();

    Ref.rt0.step( dt )
    Ref.char0.arm.skin.updateFromPose( Ref.rt0.tarPose );

    Util.debugBones( Ref.rt0.srcPose.bones, Debug, 0.08, 1, false, 0x00ff00, 0xffffff );
}

class Animation{
    constructor( gltf ){
        this.arm        = GltfUtil.parseArmature( gltf, true );
        this.clip       = GltfUtil.loadAnimationClip( gltf, null, this.arm.bindPose );
        // this.pose       = this.arm.poses.opose;
        // this.animator   = new PoseAnimator()
        //     .setClip( this.clip )
        //     .usePlacementReset( [0,0,1] ) // This animation uses Z for up.
        //     .start();
    }

    static async fetch( name, pos=[0,0,0] ){
        const gltf = await Gltf2.fetch( `/prototypes/_res/anim/mixamo/${name}.gltf` );
        return new Animation( gltf );//.setPos( pos );
    }

    // setPos( p ){ this.pose.offset.pos.copy( p ); return this; }

    // update( dt ){
    //     this.animator
    //         .step( dt )
    //         .updatePose( this.pose );

    //     this.pose.updateWorld();
    //     Util.debugBones( this.pose.bones, Debug, 0.08, 1, false );
    // }
}

class Character{
    static async fetch( url ){
        const gltf = await Gltf2.fetch( url);
        return new Character( gltf );
    }

    constructor( gltf ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Armature
        this.arm = GltfUtil.parseArmature( gltf );
        this.arm.useSkin( TranMatrixSkin );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Mesh
        const geo  = GltfUtil.loadGeoBuffers( gltf )[0];
        const mat  = MatrixSkinMaterial( 'cyan', this.arm.skin );
        this.mesh  = new THREE.Mesh( geo, mat );
    }

    setPos( p ){ this.mesh.position.fromArray( p ); return this; }
}

// NOTE: incPos is just a hack for now, more information in Retarget Source
const boneMap = [
    { src: 'mixamorig:Hips', tar: 'Hips', incPos:true },
    { src: 'mixamorig:Spine',  tar: 'Spine1' },
    { src: 'mixamorig:Spine1', tar: 'Spine2' },
    { src: 'mixamorig:Spine2', tar: 'Spine3' },
    { src: 'mixamorig:Neck', tar: 'Neck' },
    { src: 'mixamorig:Head', tar: 'Head' },

    { src: 'mixamorig:LeftShoulder', tar: 'Clavicle_L' },
    { src: 'mixamorig:LeftArm', tar: 'UpperArm_L' },
    { src: 'mixamorig:LeftForeArm', tar: 'ForeArm_L' },
    { src: 'mixamorig:LeftHand', tar: 'Hand_L' },

    { src: 'mixamorig:RightShoulder', tar: 'Clavicle_R' },
    { src: 'mixamorig:RightArm', tar: 'UpperArm_R' },
    { src: 'mixamorig:RightForeArm', tar: 'ForeArm_R' },
    { src: 'mixamorig:RightHand', tar: 'Hand_R' },

    { src: 'mixamorig:LeftUpLeg', tar: 'Thigh_L' },
    { src: 'mixamorig:LeftLeg', tar: 'Shin_L' },
    { src: 'mixamorig:LeftFoot', tar: 'Foot_L' },
    { src: 'mixamorig:LeftToeBase', tar: 'Toe_L' },

    { src: 'mixamorig:RightUpLeg', tar: 'Thigh_R' },
    { src: 'mixamorig:RightLeg', tar: 'Shin_R' },
    { src: 'mixamorig:RightFoot', tar: 'Foot_R' },
    { src: 'mixamorig:RightToeBase', tar: 'Toe_R' },
];

//#endregion
</script></body></html>