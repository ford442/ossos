<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import Util                         from '../_lib/misc/Util.js';
import fetchTexture                 from '../_lib/misc/fetchTexture.js';
import GltfUtil, { Gltf2 }          from '../_lib/misc/GltfUtil.js';

import { Armature, Pose, TranMatrixSkin, PoseAnimator, RootMotion, Maths, Quat, Vec3 } from '../../src/index';

import MatrixSkinMaterial           from '../_lib/customSkinning/MatrixSkinMaterial.js';
//#endregion

//#region MAIN
let App = useDarkScene( useThreeWebGL2(), { grid:false } );
let Ref = { 
    left    : false,
    right   : false,
};
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 45, 20, 8, [ 0, 1, 0 ] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const gltf = await Gltf2.fetch( '/prototypes/_res/models/pete/pete.gltf' );
    const bGeo = GltfUtil.loadGeoBuffers( gltf, 'Character' )[0];
    const arm  = GltfUtil.parseArmature( gltf );
    
    // console.log( 'Get', gltf.getAnimationNames() )
    
    arm.newPose( 'anim' );
    arm.useSkin( TranMatrixSkin );
    
    const mat  = MatrixSkinMaterial( 'silver', arm.skin );
    const mesh = new THREE.Mesh( bGeo, mat );
    App.scene.add( mesh );
    Ref.mesh = mesh;

    const clip = GltfUtil.loadAnimationClip( gltf, 'Walking', arm.poses.bind );
    // clip.isLooped = false;
    // clip.addEvent( 'FootL_Down', 0 );
    // clip.addEvent( 'FootR_Down', 13 );

    const animator = new PoseAnimator();
    animator.setClip( clip );
    // animator.scale = 2.0;
    // animator.onEvent = onAnimationEvent;
    // animator.atFrame( 0 );
    // animator.updatePose( pose );

    Ref.animator = animator;
    Ref.arm      = arm;

    // onPreRender( 0 );
    const mCompute = new MotionCompute( arm );
    mCompute
        .setClip( clip )
        .setFeetEffectors( 'toes.l', 'toes.r' );

    mCompute.process().computeDistance();

    clip.setRootMotionData( mCompute.flatFrames );

    // [0,0,0,0,0,0.010632596909999847,0,0,0.08283720165491104,0,0,0.15482839941978455,0,0,0.2076096534729004,0,0,0.2388806939125061,0,0,0.26190605759620667,0,0,0.2834576666355133,0,0,0.30847638845443726,0,0,0.3346388339996338,0,0,0.36082422733306885,0,0,0.38815033435821533,0,0,0.4369094967842102,0,0,0.45002931356430054,0,0,0.4955002963542938,0,0,0.5691287517547607,0,0,0.6396232843399048,0,0,0.6863535046577454,0,0,0.7163678407669067,0,0,0.7373037338256836,0,0,0.756262481212616,0,0,0.779491126537323,0,0,0.8083058595657349,0,0,0.8455933928489685,0,0,0.8851573467254639,0,0,0.8931341767311096]

    // onPreRender( 0.1 );
    // onPreRender( 0.1 );

    // console.log( String( mCompute.flatFrames ));

    setTimeout( ()=>animator.start(), 2000 );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const geo  = new THREE.PlaneGeometry( 2, 2, 1, 1 );
    geo.rotateX( -Math.PI * 0.5 );

    const floor = new THREE.Mesh( geo, checkerCrossMaterial() );
    floor.scale.setScalar( 3 );
    Ref.floor = floor;
    App.scene.add( floor );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();
});
//#endregion

let walkDist = 0;
function onPreRender( dt, et ){
    if( Ref.animator.isRunning ){
        // Generate Pose
        Ref.animator.step( dt );
        // console.log( Ref.animator.fInfo[0].kB );
        Ref.animator.updatePose( Ref.arm.poses.anim );
        
        const delta = Ref.animator.getMotion();
        // console.log( delta );
        if( delta ){

            // console.log( 'From', Ref.mesh.position.z, 'Plus',delta[2] , "@", Ref.mesh.position.z + delta[2] );
            // Ref.mesh.position.x += delta[0];
            // Ref.mesh.position.y += delta[1];
            // Ref.mesh.position.z += delta[2];

            walkDist = ( walkDist + delta[2] ) % 6;

            Ref.floor.material.offsetY = walkDist;
            

            // Debug.pnt.add( [-1, 0, Ref.mesh.position.z], 0xffffff, 1.3 );
            // Debug.pnt._updateGeometry();
        }
        
        // Update Skinned Mesh
        Ref.arm.poses.anim.updateWorld();
        Ref.arm.skin.updateFromPose( Ref.arm.poses.anim );

        // Render Bones
        // Debug.pnt.reset();
        // Debug.ln.reset();
        // Util.debugBones( Ref.arm.poses.anim.bones, Debug, 0.05, 0.8 );
    }
}

function onAnimationEvent( evtName ){
    switch( evtName ){
        case 'FootL_Down':
            Ref.left  = true;
            Ref.right = false;
            
            break;
        case 'FootR_Down':
            Ref.left  = false;
            Ref.right = true;
            // Ref.shake.start();
            break;
    }
}


class MotionCompute{
    animator = new PoseAnimator()
    pose     = null;
    arm      = null;

    footL    = null;
    footR    = null;
    // isLDown  = false;
    // isRDown  = false;
    lPoints  = [];
    rPoints  = [];

    minBound      = new Vec3();
    maxBound      = new Vec3();

    frames   = [];
    flatFrames = null;

    constructor( arm ){
        this.arm  = arm;
        this.pose = arm.newPose();
        // this.animator.onAnimationEvent = this.onEvent;
    }

    debugPoints(){
        Debug.ln.box( this.min, this.max, 0xffffff );

        for( let i=0; i < this.lPoints.length; i++ ){
            // Debug.pnt.add( this.rPoints[i], 0x00ff00, 1.2 );
            // Debug.pnt.add( this.lPoints[i], 0x00ffff, 1.2 );
        }

        return this;
    }

    computeDistance(){
        const ymin = this.minBound[1] + 0.09;
        const pos  = new Vec3();

        this.flatFrames = new Float32Array( this.lPoints.length * 3 );

        let z = 0;
        let l = 0;
        let r = 0;
        for( let i=0; i < this.lPoints.length; i++ ){
            // z = 0;
            l = 0;
            r = 0;
            if( i == 0 )                            z = 0;    // No movement
            else if( this.rPoints[i][1] <= ymin )   r = this.rPoints[i][2] - this.rPoints[i-1][2];
            else if( this.lPoints[i][1] <= ymin )   l = this.lPoints[i][2] - this.lPoints[i-1][2];
            else                                    z *= 1.0; // No feet, start applying friction
            
            z = ( l || r )? Math.max( Math.abs(r),  Math.abs(l) ) :  Math.abs(z) ;

            pos[2] += z;

            this.frames.push( pos.slice() );
            this.flatFrames.set( pos, i*3 );

            // console.log( z, pos );
            // console.log( '--', this.rPoints[i][2], ((i != 0)? this.rPoints[i-1][2] : 0) );
            // console.log( '--', this.lPoints[i][2], ((i != 0)? this.lPoints[i-1][2] : 0) );

            // Debug.pnt.add( pos, 0xffff00, 1.2 );

            // if( this.rPoints[i][1] <= ymin ) Debug.pnt.add( this.rPoints[i], 0x00ff00, 1.2 );
            // if( this.lPoints[i][1] <= ymin ) Debug.pnt.add( this.lPoints[i], 0x00ffff, 1.2 );
        }

        // console.log( this.frames );
        // console.log( this.flatFrames );

        console.log( 'Final Position', this.frames[this.frames.length-1] );
    }

    process(){
        const fCnt = this.animator.clip.frameCount;
        this.minBound.setInfinite();
        this.maxBound.setInfinite( -1 );

        for( let i=0; i < fCnt; i++ ){
            this.atKey( i );
            this.minBound.min( this.footR.world.pos );
            this.minBound.min( this.footL.world.pos );
            this.maxBound.max( this.footR.world.pos );
            this.maxBound.max( this.footL.world.pos );

            this.lPoints.push( this.footL.world.pos.slice() );
            this.rPoints.push( this.footR.world.pos.slice() ); 
        }

        return this;
    }

    // onEvent = ( name )=>{
    //     console.log( name );
    // };

    setClip( c ){ 
        this.animator.setClip( c ); 
        return this;
    }

    setFeetEffectors( lName, rName ){
        this.footL = this.pose.getBone( lName );
        this.footR = this.pose.getBone( rName );
        return this;
    }

    // setLeftLeg( name, iDown, iUp ){
    //     this.footL = this.pose.getBone( name );
    //     this.animator.clip.addEvent( 'legl_down', iDown );
    //     this.animator.clip.addEvent( 'legl_up', iUp );
    //     return this;
    // }

    // setRightLeg( name, iDown, iUp ){
    //     this.footR = this.pose.getBone( name );
    //     this.animator.clip.addEvent( 'legr_down', iDown );
    //     this.animator.clip.addEvent( 'legr_up', iUp );
    //     return this;
    // }
    
    atKey( i, skin=false, debug=false ){
        this.animator
            .atFrame( i )
            .updatePose( this.pose );

        this.pose.updateWorld();
        if( skin )  this.arm.skin.updateFromPose( this.pose );
        if( debug ) this.debugBones();
    }

    debugBones(){
        Debug.pnt.reset();
        Debug.ln.reset();
        Util.debugBones( this.pose.bones, Debug, 0.05, 0.8 );
    }
}


function checkerCrossMaterial(){
    const mat = new THREE.RawShaderMaterial({
        name            : 'CheckboxGrid',
        side            : THREE.DoubleSide,
        depthTest       : true,
        transparent 	: true,
        alphaToCoverage : true,
        extensions      : { derivatives : true },

        uniforms        : {
            offset  : { type: 'vec4',  value: [0,0] },
        },

        vertexShader    : `#version 300 es
        in	vec3    position;
        in  vec3    normal;
        in	vec2    uv;

        uniform mat4  modelMatrix;
        uniform mat4  viewMatrix;
        uniform mat4  projectionMatrix;

        out vec3  fragWPos;
        out vec2  fragUV;
        
        // ############################################################

        void main(){
            vec4 wPos       = modelMatrix * vec4( position, 1.0 );
            gl_Position     = projectionMatrix * viewMatrix * wPos;
            fragWPos        = wPos.xyz;
            fragUV          = uv;
        }`,

        fragmentShader  : `#version 300 es
        precision mediump float;
            
        uniform vec2 offset;    
        in vec3 fragWPos;
        in vec2 fragUV;
        
        out vec4 outColor;

        // #####################################################################

        float sdfCross( vec2 p, vec2 b, float r ){
            p = abs( p ); 
            p = ( p.y > p.x )? p.yx : p.xy;
            
            vec2  q = p - b;
            float k = max( q.y, q.x );
            vec2  w = ( k > 0.0 )? q : vec2( b.y - p.x, -k );
            float d = length( max( w, 0.0 ) );
            return ( ( k >0.0 )? d : -d ) + r;
        }

        vec3 hsl2rgb( vec3 c ){ // Hue: 0-1, Sat-01, Lit : 0,5
            vec3 rgb = clamp( 
                abs(
                    mod( c.x * 6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0
                ) - 1.0, 0.0, 1.0
            );

            return c.z + c.y * ( rgb - 0.5 ) * ( 1.0 - abs( 2.0 * c.z -1.0 ) );
        }

        vec3 rgb( int c ){
            return vec3(
                float( ( c >> 16 ) & 0xff ) * 0.00392156863,
                float( ( c >> 8 ) & 0xff ) * 0.00392156863,
                float( c & 0xff ) * 0.00392156863
            );
        }

        // #####################################################################
        void main(){
            outColor   = vec4( 1.0 );
            vec2 pos   = fragWPos.xz + offset;
            vec2 space = pos / 1.0;
            vec2 coord = floor( space );
            vec2 grad  = fract( space );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Checker box
            float mask   = mod( coord.x + mod( coord.y, 2.0 ), 2.0 );
            outColor.rgb = mix( rgb( 0x404040 ), rgb( 0x969696 ), mask );
            
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Crosses
            mask    = sdfCross( grad - 0.5, vec2(0.1, 0.02), 0.0 );
            mask    = 1.0 - step( 0.0, mask );

            float hue = length( coord ) / 2.8;    // Cycle some colors
            outColor.rgb = mix( outColor.rgb, hsl2rgb( vec3( hue, 1.0, 0.6) ), mask );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Outer boarder
            vec2 vMask    = step( 0.5-0.01, abs( fragUV - 0.5 ) );
            outColor.rgb *= 1.0 - max( vMask.x, vMask.y );
        }`
    });

    Object.defineProperty(mat, 'offsetX', {
        set(v){ mat.uniforms.offset.value[ 0 ] = v; },
    });

    Object.defineProperty(mat, 'offsetY', {
        set(v){ mat.uniforms.offset.value[ 1 ] = v; },
    });

    return mat;
}

</script></body></html>