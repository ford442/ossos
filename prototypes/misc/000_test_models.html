<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';

import { Armature, Pose, TranMatrixSkin, Vec3, Quat, Mat4 } from '../../src/index';
import MatrixSkinMaterial           from '../_lib/customSkinning/MatrixSkinMaterial.js';

// import Util                         from '../_lib/misc/Util.js';

import GltfUtil, { Gltf2 }          from '../_lib/misc/GltfUtil.js';
// #endregion

// #region MAIN
let App = useDarkScene( useThreeWebGL2() );
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 45, 20, 3, [0,0.8,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region DOWNLOAD FILE
    const url  = '/prototypes/_res/models/agora/alpha_1_1.gltf';
    const gltf = await Gltf2.fetch( url );
    // console.log( gltf );

    // Check if Draco is on the list, means bin is compressed.
    // console.log( 'Extensions Used: ' gltf.json.extensionsUsed );
    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region PARSE & RENDER SKELETON
    // const arm  = getArmature( gltf );
    const arm   = parseArmature( gltf );

    // console.log( arm );
    // console.log( 'Bone Count', arm.bindPose.bones.length );
    // debugBones( arm.bindPose.bones, Debug, 0.05, 0.8 );

    const tpose = arm.newPose( 'tpose' );
    getAnimationPose( gltf, tpose, 'TPose', );
    // debugBones( tpose.bones, Debug, 0.05, 0.8 );
    // arm.skin.updateFromPose( tpose );

    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region PARSE & RENDER MESH
    
    // const meshes = getMesh( gltf, null ); // Load a specific mesh
    const meshes = getMesh( gltf, null, arm ); // Load a specific mesh for skin rendering
    // console.log( 'Total Submeshes?', meshes.length );
    App.scene.add( ...meshes );
    
    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region POSING
    // const pose = arm.newPose();

    // console.log( pose.getBone('DEF-thigh.R') );

    // pose
    //     .rotWorld( 'DEF-thigh.R', -65, 'x' )
    //     .rotWorld( 'DEF-shin.R', 105, 'x' )
    //     .rotWorld( 'DEF-spine.001', -20, 'x' )
    //     .rotWorld( 'DEF-spine.002', -20, 'x' )
    //     .rotWorld( 'DEF-spine.003', -20, 'x' )
    //     .rotWorld( 'DEF-head', -20, 'x' )

    // pose.updateWorld();
    // arm.skin.updateFromPose( pose );

    // debugBones( pose.bones, Debug, 0.05, 0.8 );

    // #endregion
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});
// #endregion


function getAnimationPose( gltf, pose, name='TPose' ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Find animation
    let idx = -1;
    if( gltf.json.animations ){
        idx = gltf.json.animations.findIndex( e=>(e.name.toLowerCase() === 'tpose') );
    }

    if( idx === -1 ){ console.log( 'Animation not found with the name: ', name ); return false; }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Parse Animation
    const anim = gltf.getAnimation( idx );
    if( anim.timestamps.length > 1 ) console.warn( 'Multiple timestamps in animation named: ', name );

    for( let i of anim.tracks ){
        switch( i.transform ){
            case 0:
                pose.bones[ i.jointIndex ].local.rot.fromBuf( i.keyframes.data, 0 );
                break;
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    pose.updateWorld();
    return true;
}


function debugBones( ary, debug, flen=0.2, pntSize=1, doReset=false, boneColor=0x00ffff, jntColor=0x00ff00 ){
        const up   = new Vec3();
        const fwd  = new Vec3();

        if( doReset ){
            debug.pnt.reset();
            debug.ln.reset();
        }

        for( let b of ary ){
            up  .fromQuat( b.world.rot, Vec3.UP )
                // .scale( b.len * b.world.scl[1] )
                .scale( b.len ) // if scale exists in offset, things will render incorrectly
                .add( b.world.pos );

            fwd .fromQuat( b.world.rot, Vec3.FORWARD )
                .scale( flen )
                .add( b.world.pos );

            debug.pnt.add( b.world.pos, jntColor, pntSize, 1 );
            debug.ln.add( b.world.pos, fwd, jntColor );
            debug.ln.add( b.world.pos, up, boneColor );
        }
    }

function parseArmature( gltf, minLen=0.1 ){
    const skin  = gltf.getSkin();
    const arm   = new Armature();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create Armature Skeleton
    let b;
    for( const j of skin.joints ){
        b = arm.addBone( { name: j.name, parent: j.parentIndex } );
        if( j.rotation ) b.local.rot.copy( j.rotation );
        if( j.position ) b.local.pos.copy( j.position );
        if( j.scale )    b.local.scl.copy( j.scale );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Set offset before binding, GLTF's inverseMatrices will
    // include this in the bindpose which I think shouldnt
    if( skin.position || skin.scale || skin.rotation  ){
        const pose = arm.bindPose;
        if( skin.position ) pose.offset.pos.copy( skin.position );
        if( skin.rotation ) pose.offset.rot.copy( skin.rotation );
        if( skin.scale  )   pose.offset.scl.copy( skin.scale  );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Finalize bone & instialize one of the skinning algorithms
    arm.bind( minLen );
    arm.useSkin( TranMatrixSkin );

    return arm;
}

/** Turn GLTF Skeleton to an OSSOS Armature */
function getArmature( gltf, minLen=0.1 ){
    const skin  = gltf.getSkin();
    const arm   = new Armature();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    let b;
    for( const j of skin.joints ){
        b = arm.addBone( { name: j.name, parent: j.parentIndex } );
        if( j.rotation ) b.local.rot.copy( j.rotation );
        if( j.position ) b.local.pos.copy( j.position );
        if( j.scale )    b.local.scl.copy( j.scale );

        // console.log( j );
    }

    arm.bindPose.offset.rot.copy( skin.rotation );
    arm.bindPose.offset.scl.copy( skin.scale );

    arm.bind( minLen );
    arm.useSkin( TranMatrixSkin );

    /*
    console.log( arm.poses.bind );

    const m4 = new Mat4(  skin.joints[0].bindMatrix );
    console.log( 'Original', m4 );
    console.log( 'Inverted', m4.invert() );

    const rot = [0,0,0,0];
    const pos = [0,0,0];
    const scl = [1,0,0];
    m4.decompose( rot, pos, scl );
    console.log( 'Decompose', 'Rot', rot, 'Pos', pos, 'Scl', scl );
    console.log( 'Local', 'Rot', skin.joints[0].rotation ,'Pos', skin.joints[0].position, 'Scl', skin.joints[0].scale  );
    console.log( 'Offset', 'Rot', skin.rotation, 'Pos', skin.position, 'Scl', skin.scale );

    const mm = new Mat4().fromQuatTranScale( skin.rotation, [0,0,0], skin.scale );
    console.log( 'Offset Matrix', mm );
    
    console.log( 'Test', mm.invert().mul( m4 ) );
    mm.decompose( rot, pos, scl );
    console.log( 'Decompose2', 'Rot', rot, 'Pos', pos, 'Scl', scl );
    */

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if( skin.position || skin.scale || skin.rotation  ){
        const opose = arm.newPose( 'offset' );
        if( skin.position ) opose.offset.pos.copy( skin.position );
        if( skin.rotation ) opose.offset.rot.copy( skin.rotation );
        if( skin.scale  ) opose.offset.scl.copy( skin.scale  );
        opose.updateWorld();
    }

    return arm;
}

/** Turn GLTF Mesh into a collection of 3JS Meshes */
function getMesh( gltf, id=null, arm ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Parse out a single mesh
    const m = gltf.getMesh( id );
    if( !m || m.primitives.length == 0 ){
        console.error( 'No gltf mesh found', id );
        return null;
    }

    console.log( 'GLTF Mesh', m );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const out = [];
    let gGeo;
    let mesh;
    let mat = ( arm )
        ? MatrixSkinMaterial( 0xffffff, arm.skin )
        : new THREE.MeshPhongMaterial();

    for( let p of m.primitives ){
        console.log( 'Primitive', p );

        gGeo = geoPrimitive( p );
        mesh = new THREE.Mesh( gGeo, mat );
        out.push( mesh );
    }

    return out;
}

/** Turn GLTF Primitive data into 3JS Geometry */
function geoPrimitive( prim, useSkin=true ){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute( 'position', new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    if( prim.indices )    geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    if( prim.normal )     geo.setAttribute( 'normal', new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );
    if( prim.texcoord_0 ) geo.setAttribute( 'uv', new THREE.BufferAttribute( prim.texcoord_0.data, prim.texcoord_0.componentLen ) );

    if( useSkin && prim.joints_0 && prim.weights_0 ){
        geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
        geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data,  prim.joints_0.componentLen ) );
    }

    return geo;
}


</script></body></html>