<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import Util                         from '../_lib/misc/Util.js';
import { TranMatrixSkin, Pose }     from '../../src/index';
import { vec3, quat }               from 'gl-matrix';
import GltfUtil                     from '../_lib/misc/GltfUtil.js';
//#endregion

// #region MAIN
let App = useDarkScene( useThreeWebGL2(), { ambient:0xffffff } );
let Ref = {};
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 3, [ 0, 0.6, 0 ] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create Skinned Mesh from GLTF Model
    const gltf = await GltfUtil.fetch( '/prototypes/_res/models/MK00.gltf' );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const ikbot = new MK00( gltf );
    App.scene.add( ikbot.group );

    ikbot.setPosition( [0,0.6,0] );
    ikbot.setEyeLids( 0, 0.7 );
    ikbot.setLook( -20, -5 );
    
    ikbot.updateSkin();

    Ref.bot = ikbot;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.rLoop = App.createRenderLoop( onPreRender ).start(); // App.renderLoop();
    // let min = Infinity;
    // let max = -Infinity;
    // for( let i=0; i < 5000; i++ ){
    //     //let n = noise( i * 0.01 + 0 );  // around 0.17 and 0.85
    //     let n = noise2.simplex2( i * 0.1 + 373, 0 ); // -0.9 to 0.9
    //     //let n = noise2.perlin2( i * 0.07 + 373, 0 ); // Max Range of -0.5 & 0.5;
    //     min = Math.min( min, n );
    //     max = Math.max( max, n );
    //     // console.log( n );
    // }
    // console.log( min, max );
});
// #endregion

function onPreRender( dt, et ){
    let n0 = noise2.simplex2( et * 0.5, 0 );
    let n1 = noise2.simplex2( et * 0.2 + 7, 0 );
    let n3 = noise2.simplex2( et * 0.4 + 3, 0 ) * 0.5 + 0.5;
    let n4 = noise2.simplex2( et * 0.2 + 11, 0 );
    
    Ref.bot.setLook( 40 * n0, 20 * n1 );
    Ref.bot.setEyeLids( n3, n3 );
    Ref.bot.setPosition( [0, 0.7 + 0.2 * n4, 0] );

    Ref.bot.updateSkin();
}

import QuatEx  from '../../src/maths/QuatEx.ts';
import noise2  from '../_lib/perlin2.js';

const MAX_EYELID_ANG = 30;
const MAX_EYELID_RAD = MAX_EYELID_ANG * Math.PI / 180;

class MK00{
    constructor( gltf ){
        this.arm    = GltfUtil.parseArmature( gltf );
        this.skin   = this.arm.useSkin( TranMatrixSkin ); //new TranMatrixSkin( this.arm.bindPose );
        this.group  = new THREE.Group();
        this.pose   = this.arm.newPose();

        const nList = GltfUtil.filterNodes( gltf, { prefix: 'MKB_', isMesh: true, } );
        GltfUtil.loadNodeMeshes( gltf, nList, this.skin, this.group );
    }
    
    // #region CONTROLS
    setPosition( p ){ this.pose.posLocal( 'Root', p  ); return this; }
    setEyeLids( up, dn ){
        const q = [0,0,0,1];
        let b;

        // Clamp Range
        up = Math.min( Math.max( up, 0 ), 1 );
        dn = Math.min( Math.max( dn, 0 ), 1 );
        
        // Top Eyelid
        b = this.arm.poses.bind.getBone( 'EyelidUp' );
        quat.setAxisAngle( q, [1,0,0], -MAX_EYELID_RAD * up );
        quat.mul( q, q, b.local.rot );
        this.pose.setLocalRot( 'EyelidUp', q );

        // Bottom Eyelid
        b = this.arm.poses.bind.getBone( 'EyelidDn' );
        quat.setAxisAngle( q, [1,0,0], MAX_EYELID_RAD * dn );
        quat.mul( q, q, b.local.rot );
        this.pose.setLocalRot( 'EyelidDn', q );
        
        return this;
    }

    setLook( lonDeg, latDeg ){
        const b = this.arm.poses.bind.getBone( 'Eye' );
        const q = QuatEx.polar( [0,0,0,0], lonDeg, latDeg );
        
        quat.mul( q, q, b.local.rot );
        this.pose.setLocalRot( 'Eye', q );
        return this;
    }
    // #endregion

    updateSkin(){
        this.pose.updateWorld();
        this.skin.updateFromPose( this.pose );
    }
}

</script></body></html>