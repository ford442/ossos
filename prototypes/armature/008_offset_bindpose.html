<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import { Armature, Pose, MatrixSkin, Transform, Mat4 } from '../../src/index';

import Util                         from '../_lib/misc/Util.js';
import GltfUtil, { Gltf2 }          from '../_lib/misc/GltfUtil.js';
// #endregion

// #region MAIN
let App = useDarkScene( useThreeWebGL2() );
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 20, 20, 4, [0,1,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region DOWNLOAD FILE
    const url  = '/prototypes/_res/models/Michelle.glb';
    const gltf = await Gltf2.fetch( url );
    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region PARSE & RENDER SKELETON
    const arm  = getArmature( gltf );
    // Util.debugBones( arm.bindPose.bones, Debug, 0.05, 0.8 );

    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region PARSE & RENDER MESH
    const meshes = getMesh( gltf, null, arm ); // Load a specific mesh for skin rendering
    App.scene.add( ...meshes );

    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region TEST 1 : Render Skeleton as is without change. 
    // Correct results should be to see the mesh scale up
    // and rotate to matcht he skeleton.
    // ** BindPose with Offset with a Pose without Offset **

    // const pose = arm.newPose();                         // Clone of Bind Pose

    // pose.offset.reset();                                // Remove Offset from Bind Clone
    // pose.updateWorld();                                 // Recompute Worldspace without offset
    // arm.updateBoneLengths( pose );                      // Help render debug bones correctly
    
    // arm.skin.updateFromPose( pose );                    // Apply pose to current skinned object
    // Util.debugBones( pose.bones, Debug, 0.05, 0.8 );    // View Bones

    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region TEST 2 : Allow offset bindpose do its thing & Pose it.
    // console.log( arm.names );
    const pose = arm.newPose(); // Clone Bind Pose
    // const pose = arm.poses.offset.clone();  // Correct Final
    // const pose = arm.poses.bind.clone(); // Real Size

    // Because of scale & transformation space, to move character
    // in the correct unit space, must be done at the offset not the first bone.
    // Note, in custom shader modelMatrix is able to transform the skinned mesh too
    // instead of using the office which already contains rotation & scale to properly
    // render the character that is originally in CM & Z-Up
    pose.offset.pos[0] += 1;
    pose.offset.pos[2] -= 1;

    pose.bones[0].local.pos[0] = 1;                     // Hip - Doesn't work because its a different coord-space from offset scale
    pose.bones[0].local.pos[2] -= 1;    
    pose.bones[1].local.rot.rotY( Math.PI * -0.2 );     // Spine
    pose.bones[5].local.rot.rotX( Math.PI * -0.2 );     // Head

    pose.bones[55].local.rot.rotX( Math.PI * 0.5 );     // Thigh
    pose.bones[56].local.rot.rotX( Math.PI * -0.5 );    // Shin
    pose.bones[57].local.rot.rotX( Math.PI * -0.3 );    // Foot

    pose.bones[8].local.rot.rotZ( Math.PI * 0.3 );      // Upper Arm
    pose.bones[9].local.rot.rotZ( Math.PI * 0.6 );      // Lower Arm
    
    pose.updateWorld();                                 // Update worldspace transforms
    arm.skin.updateFromPose( pose );                    // Apply pose to current skinned object

    Util.debugBones( pose.bones, Debug, 0.05, 0.8 );    // View Bones

    // #endregion
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});
// #endregion

// #region MESH + SKIN LOADING
/** Turn GLTF Skeleton to an OSSOS Armature */
function getArmature( gltf, minLen=0.1 ){
    const skin  = gltf.getSkin();
    const arm   = new Armature();
    let hasOffset = false;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create Armature Skeleton
    let b;
    for( const j of skin.joints ){
        b = arm.addBone( { name: j.name, parent: j.parentIndex } );
        if( j.rotation ) b.local.rot.copy( j.rotation );
        if( j.position ) b.local.pos.copy( j.position );
        if( j.scale )    b.local.scl.copy( j.scale );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Set offset before binding, GLTF's inverseMatrices will
    // include this in the bindpose which I think shouldnt
    if( skin.position || skin.scale || skin.rotation  ){
        const pose = arm.bindPose;
        if( skin.position ) pose.offset.pos.copy( skin.position );
        if( skin.rotation ) pose.offset.rot.copy( skin.rotation );
        if( skin.scale  )   pose.offset.scl.copy( skin.scale  );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Finalize bone & instialize one of the skinning algorithms
    arm.bind( minLen );
    arm.useSkin( MatrixSkin );

    return arm;
}

/** Turn GLTF Mesh into a collection of 3JS Meshes */
function getMesh( gltf, id=null, arm ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Parse out a single mesh
    const m = gltf.getMesh( id );
    if( !m || m.primitives.length == 0 ){
        console.error( 'No gltf mesh found', id );
        return null;
    }

    console.log( 'GLTF Mesh', m );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const out = [];
    let gGeo;
    let mesh;
    let mat = ( arm )
        ? MatrixSkinMaterial( 0xffffff, arm.skin )
        : new THREE.MeshPhongMaterial();

    for( let p of m.primitives ){
        console.log( 'Primitive', p );

        gGeo = geoPrimitive( p );
        mesh = new THREE.Mesh( gGeo, mat );
        out.push( mesh );
    }

    return out;
}

/** Turn GLTF Primitive data into 3JS Geometry */
function geoPrimitive( prim, useSkin=true ){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute( 'position', new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    if( prim.indices )    geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    if( prim.normal )     geo.setAttribute( 'normal', new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );
    if( prim.texcoord_0 ) geo.setAttribute( 'uv', new THREE.BufferAttribute( prim.texcoord_0.data, prim.texcoord_0.componentLen ) );

    if( useSkin && prim.joints_0 && prim.weights_0 ){
        geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
        geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data,  prim.joints_0.componentLen ) );
    }

    return geo;
}
// #endregion

// #region SHADER
function MatrixSkinMaterial( val='cyan', skin ){
    const isTex    = ( val instanceof THREE.Texture || val.isTexture );
    const uniforms = {
        pose : { value: skin?.offsetBuffer },
    };

    if( !isTex ){
        let color;
        switch( typeof val ){
            case 'string':
            case 'number': color = new THREE.Color( val ); break;
            case 'object': if( Array.isArray( val ) ) color = new THREE.Color( val[0], val[1], val[2] ); break;
            default: color = new THREE.Color( 'red' ); break;
        }
        
        uniforms.color     = { type: 'vec3', value: color };
    }else{
        uniforms.texBase   = { type: 'sampler2D', value: val };
    }

    const matConfig = {
        side            : THREE.DoubleSide,
        uniforms        : uniforms,
        vertexShader    : VERT_SRC,
        fragmentShader	: ( !isTex )? FRAG_COL : FRAG_TEX,
    }

    const mat       = new THREE.RawShaderMaterial( matConfig );
    mat.extensions  = { derivatives : true }; // If not using WebGL2.0 and Want to use dfdx or fwidth, Need to load extension

    Object.defineProperty( mat, 'map', {
        set( c ){ mat.uniforms.texBase.value = c ; },
    });

    return mat;
}

// HANDLE SKINNING
const VERT_SRC = `#version 300 es
in vec3 position;   // Vertex Position
in vec3 normal;     // Vertex Normal
in vec2 uv;         // Vertex Texcoord
in vec4 skinWeight; // Bone Weights
in vec4 skinIndex;  // Bone Indices

#define MAXBONES 100             // Arrays can not be dynamic, so must set a size
uniform mat4 pose[ MAXBONES ];

uniform mat4 modelMatrix;       // Matrices should be filled in by THREE.JS Automatically.
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

out vec3 frag_wpos;             // Fragment World Space Position
out vec3 frag_norm;             // Fragment Normal
out vec2 frag_uv;               // Fragment Texcoord

////////////////////////////////////////////////////////////////////////

mat4 getBoneMatrix( mat4[ MAXBONES ] pose, vec4 idx, vec4 wgt ){
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    NORMALIZE BONE WEIGHT VECTOR - INCASE MODEL WASN'T PREPARED LIKE THAT
    If Weights are not normalized, Merging the Bone Offsets will create artifacts */
    int a = int( idx.x ),
        b = int( idx.y ),
        c = int( idx.z ),
        d = int( idx.w );
    
    wgt *= 1.0 / ( wgt.x + wgt.y + wgt.z + wgt.w );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // MERGE THE BONE OFFSETS BASED ON WEIGHT
    mat4 bone_wgt =
        pose[ a ] * wgt.x +  
        pose[ b ] * wgt.y +
        pose[ c ] * wgt.z +
        pose[ d ] * wgt.w;

    return bone_wgt;
}

////////////////////////////////////////////////////////////////////////

void main() {
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    mat4 boneMatrix = getBoneMatrix( pose, skinIndex, skinWeight );         // Get the Skinning Matrix
    
    vec4 vert       = vec4( position, 1.0 );
    vec4 skin       = boneMatrix * vert;

    // Notes, Dont really need the bindMatrix nor the bindInverseMatrix. Just apply the
    // bone matrix as is.

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    vec4 wpos       = skin;
    wpos            = modelMatrix * wpos;
    frag_wpos       = wpos.xyz;

    gl_Position     = projectionMatrix * viewMatrix * wpos;
    // gl_Position     = projectionMatrix * viewMatrix * vec4( position, 1.0 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Normal
    mat4 mbMatrix   = modelMatrix * boneMatrix;                             // Merge Model and Bone Matrices together
    frag_norm       = mat3( transpose( inverse( mbMatrix ) ) ) * normal;    // Transform Normals using bone + model matrix
}`;

// FRAGMENT THAT HANDLES BASE COLOR & LIGHTING
const FRAG_COL = `#version 300 es
precision mediump float;

////////////////////////////////////////////////////////////////////////

out     vec4 out_color;
in      vec3 frag_wpos;
in      vec3 frag_norm;

uniform vec3 color;

////////////////////////////////////////////////////////////////////////

#define LITCNT 2
const vec3[] light_pos = vec3[](
    vec3( 0.0, 0.5, 1.0 ),
    vec3( -1.0, 0.0, 1.0 )
);

float computePointLights( vec3[LITCNT] lights, vec3 norm ){
    vec3 light_vec;
    vec3 light_dir;

    float dist;
    float attenuation;
    float diffuse     = 0.0;
    float constant    = 0.5;
    float linear      = 0.5;
    float quadratic   = 0.5;
    
    for( int i=0; i < LITCNT; i++ ){
        light_vec       = lights[i].xyz - frag_wpos;
        light_dir       = normalize( light_vec );
        dist            = length( light_vec );
        attenuation     = 1.0 / ( constant + linear * dist + quadratic * (dist * dist) );
        diffuse        += max( dot( norm, light_dir ), 0.0 ) * attenuation;
    }

    return diffuse;
}

const vec3 sun_pos = vec3( 10.0, 10.0, 10.0 );
float computeDirLight( vec3 lPos, vec3 norm ){
    return max( dot( norm, normalize( lPos ) ), 0.0 );
}

void main(){
    //vec3 norm   = normalize( cross( dFdx(frag_wpos), dFdy(frag_wpos) ) ); // Low Poly Normals
    vec3 norm     = normalize( frag_norm ); // Model's Normals            
    
    float diffuse = 0.15; // ambient light
    diffuse      += computePointLights( light_pos, norm );
    diffuse      += computeDirLight( sun_pos, norm );

    out_color     = vec4( color * diffuse, 1.0 );

    //out_color.rgb = vec3( 1.0, 0.0, 0.0 );
}`;
// #endregion


</script></body></html>