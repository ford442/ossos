<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';

import { Armature, Pose, TranMatrixSkin,
    Transform, Mat4,
} from '../../src/index';
import MatrixSkinMaterial           from '../_lib/customSkinning/MatrixSkinMaterial.js';
import Util                         from '../_lib/misc/Util.js';

import GltfUtil, { Gltf2 }          from '../_lib/misc/GltfUtil.js';
// #endregion

// #region MAIN
let App = useDarkScene( useThreeWebGL2() );
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 20, 20, 3, [0,1,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region DOWNLOAD FILE
    const url  = '/prototypes/_res/models/Michelle.glb';
    const gltf = await Gltf2.fetch( url );
    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region PARSE & RENDER SKELETON
    const arm  = getArmature( gltf );
    Util.debugBones( arm.bindPose.bones, Debug, 0.05, 0.8 );
    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region PARSE & RENDER MESH
    const meshes = getMesh( gltf, null, arm ); // Load a specific mesh for skin rendering
    App.scene.add( ...meshes );
    // #endregion

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // #region POSING
    console.log( arm.names );
    const pose = arm.newPose();
    pose.bones[0].local.pos[0] = 1;                     // Hip
    pose.bones[0].local.pos[2] -= 1;    
    pose.bones[1].local.rot.rotY( Math.PI * -0.2 );     // Spine
    pose.bones[5].local.rot.rotX( Math.PI * -0.2 );     // Head

    pose.bones[55].local.rot.rotX( Math.PI * 0.5 );     // Thigh
    pose.bones[56].local.rot.rotX( Math.PI * -0.5 );    // Shin
    pose.bones[57].local.rot.rotX( Math.PI * -0.3 );    // Foot

    pose.bones[8].local.rot.rotZ( Math.PI * 0.3 );      // Upper Arm
    pose.bones[9].local.rot.rotZ( Math.PI * 0.6 );      // Lower Arm

    pose.updateWorld();                              // Update
    arm.skin.updateFromPose( pose );                 // Update Skinning Shaders
    Util.debugBones( pose.bones, Debug, 0.05, 0.8 ); // View Bones
    // #endregion
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});
// #endregion


/** Turn GLTF Skeleton to an OSSOS Armature */
function getArmature( gltf, minLen=0.1 ){
    const skin  = gltf.getSkin();
    const arm   = new Armature();
    let hasOffset = false;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create Armature Skeleton
    let b;
    for( const j of skin.joints ){
        b = arm.addBone( { name: j.name, parent: j.parentIndex } );
        if( j.rotation ) b.local.rot.copy( j.rotation );
        if( j.position ) b.local.pos.copy( j.position );
        if( j.scale )    b.local.scl.copy( j.scale );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // APPLY OFFSET TRANFORM - THEN CLEARN UP THE TRANSFORM HEIRARCHY
    if( skin.position || skin.scale || skin.rotation  ){
        const pose = arm.bindPose;
        const t    = new Transform();
        let   pworld;

        // Apply Offset Transform to BindPose
        if( skin.position ) pose.offset.pos.copy( skin.position );
        if( skin.rotation ) pose.offset.rot.copy( skin.rotation );
        if( skin.scale  )   pose.offset.scl.copy( skin.scale  );
        pose.updateWorld();     // Create Worldspace Skeleton with Offset Applied
        pose.offset.reset();    // Clear out offset to rebuild localspace without it

        for( let b of pose.bones ){
            // Bone's parent worldspace Transform
            pworld = b.pindex !== -1 
                ? pose.bones[ b.pindex ].world 
                : pose.offset;

            t.fromInvert( pworld );             // Invert Parent's Worldspace Transform
            b.local.fromMul( t, b.world );      // Then apply to bone to compute localspace
            b.local.scl.xyz( 1, 1, 1 );         // Prevent scale offset from propegating
            b.world.fromMul( pworld, b.local ); // Recompute worldspace to propegate scaleless offset
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Finalize bone & instialize one of the skinning algorithms
    arm.bind( minLen );
    arm.useSkin( TranMatrixSkin ); // Unreal Engine: Transform Worldspace to Mat4x4

    return arm;
}

/** Turn GLTF Mesh into a collection of 3JS Meshes */
function getMesh( gltf, id=null, arm ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Parse out a single mesh
    const m = gltf.getMesh( id );
    if( !m || m.primitives.length == 0 ){
        console.error( 'No gltf mesh found', id );
        return null;
    }

    console.log( 'GLTF Mesh', m );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const out = [];
    let gGeo;
    let mesh;
    let mat = ( arm )
        ? MatrixSkinMaterial( 0xffffff, arm.skin )
        : new THREE.MeshPhongMaterial();

    for( let p of m.primitives ){
        console.log( 'Primitive', p );

        gGeo = geoPrimitive( p );
        mesh = new THREE.Mesh( gGeo, mat );
        out.push( mesh );
    }

    return out;
}

/** Turn GLTF Primitive data into 3JS Geometry */
function geoPrimitive( prim, useSkin=true ){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute( 'position', new THREE.BufferAttribute( prim.position.data, prim.position.componentLen ) );

    if( prim.indices )    geo.setIndex( new THREE.BufferAttribute( prim.indices.data, 1 ) );
    if( prim.normal )     geo.setAttribute( 'normal', new THREE.BufferAttribute( prim.normal.data, prim.normal.componentLen ) );
    if( prim.texcoord_0 ) geo.setAttribute( 'uv', new THREE.BufferAttribute( prim.texcoord_0.data, prim.texcoord_0.componentLen ) );

    if( useSkin && prim.joints_0 && prim.weights_0 ){
        geo.setAttribute( 'skinWeight', new THREE.BufferAttribute( prim.weights_0.data, prim.weights_0.componentLen ) );
        geo.setAttribute( 'skinIndex',  new THREE.BufferAttribute( prim.joints_0.data,  prim.joints_0.componentLen ) );
    }

    return geo;
}

</script></body></html>