<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import useTransformMultiControl     from '../_lib/useTransformMultiControl.js';
import Util                         from '../_lib/misc/Util.js';

import facedCube                    from '../_lib/meshes/facedCube.js';

import { 
    Armature, Quat, Vec3, Transform,
} from '../../src/index';

import {
    BoneAxes, IKTarget, IKChain, lookSolver,
} from '../../src/kinematics2/index';
// #endregion

// #region MAIN
let Debug;
let App = useDarkScene( useThreeWebGL2() );
let Ref = {
    gizmo   : useTransformMultiControl( App, 2 ).useAxes(),
    tarPos  : [0,0.7,3.5],
    polPos  : [0,3.0,2.0],
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 90, 20, 6, [ 0, 1.0, 0 ] );
    Debug = await useVisualDebug( App );
    Ref.gizmo.setPos( 0, Ref.tarPos );
    Ref.gizmo.setPos( 1, Ref.polPos );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Build Skeleton
    const arm = new Armature();
    const b0  = arm.addBone( { name:'b0', pos:[0,0.5,0], parent:undefined } );
    const b1  = arm.addBone( { name:'b1', pos:[0,1.96,0], parent:b0 } );
    const b2  = arm.addBone( { name:'b2', pos:[0,1.78,0], parent:b1 } );
    const b3  = arm.addBone( { name:'b3', pos:[0,0.71,0], parent:b2 } );

    arm.bind( 0.001 );

    // Util.debugBones( arm.poses.bind.bones, Debug, 0.2, 1, false );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const pose   = arm.newPose();
    const chain  = new IKChain( arm.bindPose.getBones( ['b0','b1','b2','b3'] ), BoneAxes.UFR );
    const target = new IKTarget();

    target
        .setPositions( Ref.tarPos, Ref.polPos )
        .resolveTarget( chain, pose );

    target.debug( Debug );

    // pose.reset();
    asincArcCompose( target, chain, pose );

    pose.updateWorld();
    Util.debugBones( pose.bones, Debug, 0.2, 1, false );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.chain   = chain;
    Ref.pose    = pose;
    Ref.target  = target;
    Ref.arm     = arm;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const cubes = [];
    const scl   = 0.2;
    for( let i=0; i < chain.links.length-1; i++ ){
        const c = boneCube( [scl, chain.links[i].len, scl ] );
        cubes.push( c )
        App.scene.add( c );
    }

    Ref.cubes = cubes;
    updateCubes();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //App.createRenderLoop( onPreRender ).start();
    App.renderLoop();
});

Ref.gizmo.onMove = (i, p)=>{
    Debug.reset();

    // ----------------------
    switch( i ){
        case 0: Ref.tarPos = p; break;
        case 1: Ref.polPos = p; break;
    }

    // ----------------------
    Ref.pose.reset();
    Ref.target.setPositions( Ref.tarPos, Ref.polPos );
    asincArcCompose( Ref.target, Ref.chain, Ref.pose );

    // ----------------------
    Ref.pose.updateWorld();
    Util.debugBones( Ref.pose.bones, Debug, 0.2, 1, false );
    updateCubes();
};

function onPreRender( dt, et ){}

function boneCube( scl=[0.1,1,0.1] ){
    const geo = new THREE
        .BoxGeometry( 1, 1, 1 )
        .translate( 0, 0.5, 0 )
        .scale( scl[0], scl[1], scl[2] );

    const mat = [
        new THREE.MeshBasicMaterial( { color: 0x00ff00 } ), // Left
        new THREE.MeshBasicMaterial( { color: 0x777777 } ), // Right
        new THREE.MeshBasicMaterial( { color: 0x0000ff } ), // Top
        new THREE.MeshBasicMaterial( { color: 0x222222 } ), // Bottom
        new THREE.MeshBasicMaterial( { color: 0xff0000 } ), // Forward
        new THREE.MeshBasicMaterial( { color: 0xffffff } ), // Back
    ];

    return new THREE.Mesh( geo, mat );
}

function updateCubes(){
    const c     = Ref.cubes;
    const p     = Ref.pose;
    const ch    = Ref.chain;

    let b;
    for( let i=0; i < ch.links.length-1; i++ ){
        b = p.getBone( ch.links[i].index );
        c[ i ].position.fromArray( b.world.pos );
        c[ i ].quaternion.fromArray( b.world.rot );
    }
}
// #endregion

// #region SOLVER

function asincArcCompose( target, chain, pose ){
    // Resolve the target to the current pose data
    target.resolveTarget( chain, pose );

    // Align the the root bone to the target direction
    lookSolver( target, chain, pose );

    // Compute all the values needed to compute points on an arc 
    // based on 2 bits of input, chord length and arc length
    const o = calcAsincArc( target, chain, pose );
    
    if( target.dist >= chain.len ) chain.resetPoseLocal( pose, 1 );
    else{
        // Compute initial points on the arc for each bone
        const points = calcArcPoints( target, chain, o, o.arcAngle < Math.PI );
        // for( let p of points ) Debug.pnt.add( p, 0xffffff, 3, 0 );

        // Move all the points torward IK target point
        iterateForward( target, chain, points );
        // for( let p of points ) Debug.pnt.add( p, 0xff00ff, 3, 0 );

        // Move all points toward IK origin point
        iterateBackward( target, chain, points );
        // for( let p of points ) Debug.pnt.add( p, 0xffff00, 3, 2 );

        // Convert point data into rotations that can be applied to bones
        applyPointsToPose( target, chain, pose, points );
    }
}

// Using two points of input, Chord Length & Arc Length
// Compute all the remaining bits of information that defines an arc
function calcAsincArc( tar, chain, pose ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    const chordLen = tar.dist;  // Target distance substitutes chord length
    const arcLen   = chain.len; // Chain length substitutes Arc Length

    // Angle in radius of the arc with an arc length & chord length
    // NOTE: should be arcLen / chordLen but doesn't work correctly with his version of asinc
    // Also asinc results in half angle, so 2x will give full angle
    const arcAngle = 2 * asinc( chordLen / arcLen ); 
    if( arcLen <= chordLen || isNaN( arcAngle ) || arcAngle <= 0 || arcAngle > Math.PI * 2 ){
        return null;
    }

    // Radius of the circle the arc is part of
    const radius        = arcLen / arcAngle;

    // Distance frin mid point of the chord line to the circle center
    const centerOffset  = Math.sqrt( radius**2 - ( chordLen / 2 ) ** 2 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Chord line mid point
    const mid = new Vec3().fromLerp( tar.startPos, tar.endPos, 0.5 );
    const up  = tar.twist.clone();

    // const axis = norm( cross( [0,1,0], dir ) ); // Ortho direction between up & chord dir
    // const up   = norm( cross( dir, axis ) );    // Direction toward circle center

    // If angle is over 180d, flip direction to circle center
    if( arcAngle <= Math.PI ) up.negate();

    // Circle center, up * chordMidOffset + chordMid
    const center = new Vec3().fromScaleThenAdd( centerOffset, up, mid );

    return {
        radius, arcAngle, centerOffset, chordLen,
        centerPos   : center,
        midPos      : mid,
        orthoAxis   : tar.ortho,
    };
}

// Two ways to compute points on the arc, either one works
// better depending on which hemisphere of the arc is in
function calcArcPoints( tar, chain, o, useChord=true ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Init Point Data
    const points = Array.from( { length: chain.len }, ()=>new Vec3() );
    points[0].copy( tar.startPos );

    // const tt = new Vec3();
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute plane vectors to create co-planer points
    // Need to know where the Up and Right directions of the plane

    // Compute the UV vectors using the IKTarget start point as the origin
    const u = new Vec3( tar.startPos ).sub( o.centerPos ).norm();
    const v = new Vec3( tar.endPos ).sub( o.centerPos );
    // Debug.ln.add( o.centerPos, tt.fromScaleThenAdd( 2, u, o.centerPos ), 0xff00ff );
    // Debug.ln.add( o.centerPos, tt.fromScaleThenAdd( 2, v.norm(), o.centerPos ), 0xff00ff );

    const p = new Vec3().fromCross( u, v ); // axis to help make V orthogonal to U
    // Debug.ln.add( o.centerPos, tt.fromScaleThenAdd( 2, p.norm(), o.centerPos ), 0xffffff );

    v.fromCross( p, u ).norm();
    
    // When arcAngle is over pi, the direction of the circle center is flipped
    // so negate V to flip it the right side up so it matches twist direction
    if( o.arcAngle > Math.PI ) v.negate();
    // Debug.ln.add( o.centerPos, tt.fromScaleThenAdd( 2, v, o.centerPos ), 0xffffff );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute points
    let rad = 0;

    if( useChord ){
        // Compute sub arc using bone len as chord len,
        // this allows to properly place varied segment lengths
        // onto a curve which works very well for arcs less then 180deg

        const clamp  = ( v )=>Math.min( 1, Math.max( -1, v ) );
        for( let i=0; i < chain.links.length-1; i++ ){
            // NOTE: asin will result to a HALF Angle, so * 2 gives correct angle
            // arcAngle = 2 * Math.asin( chordLen / ( 2 * radius ) );
            rad += 2 * Math.asin( clamp( chain.links[i].len / ( 2 * o.radius ) ) );
            points[ i+1 ].fromArc( o.radius, u, v, rad, o.centerPos );
        }
    }else{
        // Use ArcLength and the Bone Lengths to compute the general position
        // on the arc. This is a less accurate way to compute a point but
        // when coupled with F&B step it works better in arcs greater then
        // 180deg

        let len = 0;
        for( let i=0; i < chain.links.length-1; i++ ){
            len += chain.links[i].len;
            rad  = ( len / chain.len ) * o.arcAngle;
            points[ i+1 ].fromArc( o.radius, u, v, rad, o.centerPos );
        }
    }

    return points;
}

// #endregion

// #region FABRIK-LIKE
// Move points torward the target point
function iterateForward( tar, chain, pnts ){
    const v = new Vec3();
    pnts.at( -1 ).copy( tar.endPos );           // Move last point to target position

    for( let i = chain.links.length-1; i > 1; i-- ){
        v   .fromSub( pnts[i-1], pnts[i] )      // Direction to parent point
            .norm()
            .scale( chain.links[ i-1 ].len )    // Resize to bone's length
            .add( pnts[i] )                     // Move away from child
            .copyTo( pnts[i-1] );               // Save result back as parent position
    }
}

// Move points toward the origin point
function iterateBackward( tar, chain, pnts ){
    const v = new Vec3();
    for( let i = 0; i < chain.links.length-1; i++ ){
        v   .fromSub( pnts[i+1], pnts[i] )    // Direction to child point
            .norm()
            .scale( chain.links[ i ].len )    // Resize to bone's length
            .add( pnts[i] )                   // Move away from parent
            .copyTo( pnts[i+1] );             // Save result back as child position
    }
}

// Turn point data into rotations & apply to bones
function applyPointsToPose( tar, chain, pose, pnts ){
    const fromDir = new Vec3();
    const toDir   = new Vec3();
    const parent  = new Transform();
    let lnk;
    let bone;

    for( let i=0; i < chain.links.length-1; i++ ){
        lnk     = chain.links[ i ];
        bone    = pose.getBone( lnk.index );
    
        // Compute the bone's tail current position in worldspace
        pose.getWorldTransform( bone.pindex, parent );
        bone.world.fromMul( parent, bone.local );

        // Direction bone is pointing toward
        fromDir.fromQuat( bone.world.rot, lnk.axes.swing ).norm();
        
        // Direction toward target point
        toDir.fromSub( pnts[i+1], bone.world.pos ).norm();

        bone.local.rot
            .fromSwing( fromDir, toDir )    // Rotation FROM > TO
            .mul( bone.world.rot )          // Apply to WS Rotation of bone
            .pmulInvert( parent.rot )       // To Local Space
            .norm();                        // Normalize
    }
}

// #endregion

// #region ASINC
// https://www.youtube.com/watch?v=UNrrd_XhPMA
// https://www.youtube.com/watch?v=S-zAk6VqL-E
// https://www.youtube.com/watch?v=docgrYp6A88
// https://www.youtube.com/watch?v=MULuu-bkPKs
// https://discussions.unity.com/t/ik-chain/406592/10
function asinc( x0 ){
    let   x  = 6 * ( 1-x0 );
    const x1 = x;  
    let   a  = x;                                        x *= x1; 
    a += x                   / 20.0;                     x *= x1; 
    a += x * 2.0             / 525.0;                    x *= x1; 
    a += x * 13.0            / 37800.0;                  x *= x1; 
    a += x * 4957.0          / 145530000.0;              x *= x1; 
    a += x * 58007.0         / 16216200000.0;            x *= x1;
    a += x * 1748431.0       / 4469590125000.0;          x *= x1; 
    a += x * 4058681.0       / 92100645000000.0;         x *= x1;
    a += x * 5313239803.0    / 1046241656460000000.0;    x *= x1;
    a += x * 2601229460539.0 / 4365681093774000000000.0; // x^10
    return Math.sqrt( a );
}
// #endregion

</script></body></html>