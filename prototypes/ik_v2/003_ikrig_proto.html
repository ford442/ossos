<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
import useTransformMultiControl     from '../_lib/useTransformMultiControl.js';
import Util                         from '../_lib/misc/Util.js';
import GltfUtil, { Gltf2 }          from '../_lib/misc/GltfUtil.js';
import MatrixSkinMaterial           from '../_lib/customSkinning/MatrixSkinMaterial.js';

import { 
    Armature, TranMatrixSkin,
    Quat, Vec3, Transform, 
} from '../../src/index';

import {
    BoneAxes, IKTarget, IKChain, 
    lookSolver, twoBoneSolver, limbSolver,
} from '../../src/kinematics2/index';
// #endregion

// #region MAIN
let Debug;
let App = useDarkScene( useThreeWebGL2() );
let Ref = {
    gizmo : useTransformMultiControl( App, 2 ).useAxes(),
    tarPos : [0,0.7,0.5],
    polPos : [0,0.7,-1],
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 20, 20, 3, [ 0, 0.8, 0 ] );
    Debug = await useVisualDebug( App );
    // Ref.gizmo.setPos( 0, Ref.tarPos );
    // Ref.gizmo.setPos( 1, Ref.polPos );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Load Character
    const gltf = await Gltf2.fetch( '/prototypes/_res/models/nabba/nabba.gltf' );
    const arm  = GltfUtil.parseArmature( gltf, false, 0.05 );
    arm.useSkin( TranMatrixSkin );
    Ref.arm = arm;

    const geo  = GltfUtil.loadGeoBuffers( gltf )[0];
    const mat  = MatrixSkinMaterial( 'gray', arm.skin );
    const mesh = new THREE.Mesh( geo, mat );

    App.scene.add( mesh );
    // Util.debugBones( arm.poses.bind.bones, Debug, 0.05, 1, false );
    // arm.skin.updateFromPose( arm.bindPose );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup Rig
    const rig = new IKRig( arm.bindPose ); // Must be a TPose !!!
    rig.addSet( { 
        name    : 'arm.l', 
        solver  : 'limb', 
        bones   : ['UpperArm_L','ForeArm_L','Hand_L'],
        axes    : BoneAxes.RBD, 
    } );

    Ref.rig = rig;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup Gizmos
    Ref.tarPos = rig.getEndPosition( 'arm.l' );
    Ref.polPos = Ref.tarPos.clone().add( [0,0,-0.5] );
    Ref.gizmo.setPos( 0, Ref.tarPos );
    Ref.gizmo.setPos( 1, Ref.polPos );

    // rig.getSet( 'arm.l' ).chain.debug( Debug, rig.pose );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // rig.setTargetPositions( 'arm.l', Ref.tarPos, Ref.polPos );
    // rig.runSolvers( Debug );
    // arm.skin.updateFromPose( rig.pose );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //App.createRenderLoop( onPreRender ).start();
    App.renderLoop();
});

Ref.gizmo.onMove = (i, p)=>{

    switch( i ){
        case 0: Ref.tarPos = p; break;
        case 1: Ref.polPos = p; break;
    }

    // Set Targets & Run IK Solvers
    Ref.rig
        .setTargetPositions( 'arm.l', Ref.tarPos, Ref.polPos )
        .runSolvers();

    // Apply pose to skinned mesh
    Ref.arm.skin.updateFromPose( Ref.rig.pose );

    // Debug.reset();
    // Util.debugBones( Ref.rig.pose.bones, Debug, 0.05, 1, false );

};

function onPreRender( dt, et ){}
// #endregion

// #region IK RIG

const IK_SOLVERS = {
    'look'      : lookSolver,
    'twoBone'   : twoBoneSolver,
    'limb'      : limbSolver,
};

class IKSet{
    // #region MAIN
    name    = '';
    order   = 0;
    target  = new IKTarget();
    solver  = null;
    chain   = null;

    constructor( name, order=0 ){
        this.name  = name;
        this.order = order;
    }

    setBones( bones, tPose, axes=BoneAxes.UFR ){
        this.chain = new IKChain( tPose.getBones( bones ), axes );
        return this;
    }

    setSolver( s ){
        this.solver = ( typeof s )? IK_SOLVERS[ s ] : s;
        return this;
    }
    // #endregion

    updatePose( pose, debug ){ this.solver( this.target, this.chain, pose, debug ); }
}

class IKRig{
    // #region MAIN
    sets      = [];         // IK Chain Sets
    names     = {};         // Names to Index Mapping
    pose      = null;       // Working Pose

    constructor( tpose ){
        this.pose = tpose.clone();   
    }
    // #endregion

    // #region SETUP
    getSet( name ){ return this.sets[ this.names[ name ] ]; }
    addSet( opt ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Setup Defaults
        opt = Object.assign( { 
            order   : 0, 
            name    : '', 
            bones   : [], 
            axes    : BoneAxes.UFR,
            solver  : 'look',   // string | fn()
        }, opt );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Validate things
        if( opt.bones.length === 0 ) return this;
        if( !opt.name )              opt.name = 'set' + this.sets.length;
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Build IK Set
        const s = new IKSet( opt.name, opt.order )
            .setBones( opt.bones, this.pose, opt.axes )
            .setSolver( opt.solver );

        this.sets.push( s );
        this.#reorder();

        return this;
    }

    #reorder(){
        // Sort IK Sets
        this.sets.sort( (a,b)=>
            ( a.order === b.order )? 0 : 
            ( a.order < b.order )  ? -1 : 1 
        );

        // Reset names to index mapping
        for( let i=0; i < this.sets.length; i++ ){
            this.names[ this.sets[i].name ] = i; 
        }
    }
    // #endregion

    getEndPosition( name ){
        const s = this.sets[ this.names[ name ] ];
        return this.pose.getWorldPosition( s.chain.lastLink.index );
    }

    setTargetPositions( name, tarPos, polPos=null ){
        const s = this.sets[ this.names[ name ] ];
        if( s ) s.target.setPositions( tarPos, polPos );
        else    console.log( 'Set name not found', name );
        return this;
    }

    // #region EXECUTION
    // Default Executor, Will use IKSet.order to determine execution order
    executor = ( rig, debug )=>{
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Run IK solver for each chain set
        for( const s of this.sets ){
            s.updatePose( this.pose, debug );
            // s.target.debug( debug );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Recompute worldspace pose
        this.pose.updateWorld();
    };

    runSolvers( debug ){ this.executor( this, debug ); return this; }
    // #endregion
}

// #endregion

</script></body></html>